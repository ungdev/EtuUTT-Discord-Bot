{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EtuUTT bot Discord","text":"<p>Ceci est la documentation du bot Discord d\u00e9velopp\u00e9 et h\u00e9berg\u00e9 par l'UNG, utilis\u00e9 pour g\u00e9rer le serveur des \u00e9tudiants de l'UTT.</p> <p>Si c'est la premi\u00e8re fois que vous ouvrez cette documentation, nous vous recommendons de commencer par la partie Explications.</p>"},{"location":"explanation/","title":"Accueil","text":""},{"location":"explanation/#motifs-du-projet","title":"Motifs du projet","text":"<p>Ce projet est une r\u00e9\u00e9criture du Bot du serveur Discord UTT.</p> <p>Ce dernier a \u00e9t\u00e9 \u00e9crit par Ivann Laruelle en mars 2020, au tout d\u00e9but du confinement. La chose s'est faite plus ou moins dans l'urgence, \u00e0 cause de la n\u00e9cessit\u00e9 soudaine de maintenir un contact entre les \u00e9tudiants en ces temps covid\u00e9s.</p> <p>Le plus gros du code a \u00e9t\u00e9 \u00e9crit en une nuit. Il y a bien eu quelques ajouts de fonctionnalit\u00e9 par la suite, mais la plus grande partie n'a pour ainsi dire jamais \u00e9t\u00e9 refactor.</p> <p>En plus de cette urgence, le bot a \u00e9t\u00e9 \u00e9crit avec la librairie <code>Discord.js</code>, qu'Ivann n'avait jamais utilis\u00e9 auparavant. Cette derni\u00e8re est con\u00e7ue en Javascript, qui n'\u00e9tait pas le langage avec lequel Ivann \u00e9tait le plus \u00e0 l'aise.</p> <p>Tout cela combin\u00e9 a entrain\u00e9 beaucoup d'antipatterns, de r\u00e9p\u00e9titions et de mauvais usages des fonctionnalit\u00e9s de la librairie.</p> <p>Signalons \u00e9galement que depuis cette \u00e9poque, l'API de Discord a beaucoup \u00e9volu\u00e9. Les commandes slash ont fait leur apparition et plusieurs nouvelles versions de l'API ont eu le temps d'\u00eatre mises \u00e0 disposition et d'\u00eatre d\u00e9pr\u00e9ci\u00e9es.</p> <p>Enfin, Ivann a \u00e9t\u00e9 dipl\u00f4m\u00e9 en 2022.</p> <p>Bref, le code commence \u00e0 dater et n'est pas incroyablement bien \u00e9crit. De plus son cr\u00e9ateur et ses mainteneurs ne sont plus l\u00e0.</p> <p>Donc quitte \u00e0 reprendre le projet, autant le refaire int\u00e9gralement, en le faisant plus sereinement, avec des technologies mieux maitris\u00e9es et en mettant mieux \u00e0 profit les fonctionnalit\u00e9s offertes par Discord et par les librairies utilis\u00e9es.</p>"},{"location":"explanation/#philosophie-du-projet","title":"Philosophie du projet","text":"<p>En partant de tout ce que nous avons vu ci-dessus, il apparait clair que la principale ligne directrice doit \u00eatre de prendre notre temps pour pleinement maitriser nos outils et concevoir un bot plus performant et plus ergonomique, en utilisant pour cela moins de code.</p> <p>Le nouveau bot utilisera autant que possible les commandes slash de Discord.</p> <p>\u00c0 partir de \u00e7a, il est \u00e9galement recherch\u00e9 la r\u00e9duction de la verbosit\u00e9 et des r\u00e9p\u00e9titions du code. \u00c0 terme, on vise une parit\u00e9 en termes de fonctionnalit\u00e9, mais avec beaucoup moins de lignes. Le programme actuel contient 6599 lignes de Javascript ; concevoir le nouveau en 3000 lignes environ est un objectif \u00e0 la fois souhaitable et r\u00e9alisable.</p>"},{"location":"explanation/conventions/","title":"Conventions","text":"<p>Cette page traite des conventions utilis\u00e9es pour le d\u00e9veloppement du bot \u00e9tu.</p>"},{"location":"explanation/conventions/#langue","title":"Langue","text":"<p>Les noms, de fonctions, de classe, de fichiers et de dossiers sont en anglais.</p> <p>Les docstrings et la documentation sont en fran\u00e7ais.</p> <p>De mani\u00e8re g\u00e9n\u00e9rale, demandez-vous juste \u00e0 qui vous \u00eates en train d'\u00e9crire :</p> <ul> <li>si vous \u00e9crivez pour la machine, c'est en anglais</li> <li>si vous \u00e9crivez pour des \u00eatres humains, c'est en fran\u00e7ais</li> </ul>"},{"location":"explanation/conventions/#gestion-de-version","title":"Gestion de version","text":"<p>Le projet utilise Git pour g\u00e9rer les versions et GitHub pour h\u00e9berger le d\u00e9p\u00f4t distant.</p> <p>La branche de r\u00e9f\u00e9rence est la branche <code>main</code>. Aucun <code>push</code> direct n'est autoris\u00e9 sur cette branche. Aucune fusion de code dont la CI \u00e9choue n'est autoris\u00e9e non plus.</p> <p>L'envoi de modifications sur la branche <code>main</code> doit se faire uniquement par Pull Requests.</p>"},{"location":"explanation/conventions/#nommage-des-commits","title":"Nommage des commits","text":"<p>Les noms des commits doivent \u00eatre en anglais. Si un commit effectue une action en particulier, le type de cette action doit \u00eatre indiqu\u00e9 en d\u00e9but de message :</p> <ul> <li>Les commits qui r\u00e9solvent un bug commencent par \"fix:\"   suivi de la description du bug ; exemple : <code>fix: spanish inquisition wasn't expected</code></li> <li>Les commits qui ajoutent une nouvelle fonctionnalit\u00e9 commencent par \"feat:\"   suivi de la description de la fonctionnalit\u00e9 ; exemple : <code>feat: add a new silly walk</code></li> <li>Les commits qui refactorent du code commencent par \"refactor:\",   suivi de la description du refactor ;   exemple : <code>refactor: more explicit separation from the Judean's People Front</code></li> <li>Les commits qui ajoutent de la documentation commencent par \"doc:\",   suivi de la description de ce qui est document\u00e9 ;   exemple : <code>doc: explain how to use the Holy Hand Grenade of Antioche</code></li> </ul> <p>Si un de vos commits n'accomplit pas exactement un type de t\u00e2che, il est possible qu'il soit pr\u00e9f\u00e9rable de le d\u00e9couper en commits plus petits. Mais ne partez pas dans le vice inverse ; ne faites pas des micro-commits.</p> <p>Pour plus d'information, allez sur le site des Commits Conventionnels.</p>"},{"location":"explanation/conventions/#gestion-des-branches","title":"Gestion des branches","text":"<p>La branche <code>main</code> est destin\u00e9e uniquement \u00e0 recevoir des merge commits. Elle doit recevoir, jamais donner. Lorsqu'une de vos branches est en conflit avec la branche <code>main</code>, vous devez donc <code>rebase</code>, jamais <code>merge</code>.</p> <p>En d'autres termes, vous devez respecter les deux r\u00e8gles suivantes :</p> <ol> <li>la branche <code>main</code> doit contenir seulement des merge commits</li> <li>seule la branche <code>main</code> doit contenir des merge commits</li> </ol> Bien \u2714\ufe0fPas bien \u274c <pre><code>gitGraph:\n    commit id: \"initial commit\"\n    branch bar\n    checkout main\n    checkout bar\n    commit id: \"baz\"\n    checkout main\n    merge bar id: \"Merge branch bar\"\n    branch foo\n    commit id: \"foo a\"\n    commit id: \"foo b\"\n    commit id: \"foo c\"\n    checkout main\n    merge foo id: \"Merge branch foo\"</code></pre> <pre><code>gitGraph:\n    commit\n    branch bar\n    branch foo\n    commit id: \"foo a\"\n    commit id: \"foo b\"\n    checkout main\n    checkout bar\n    commit id: \"baz\"\n    checkout main\n    merge bar id: \"Merge branch bar\"\n    checkout foo\n    merge main id: \"Merge branch main\"\n    commit id: \"foo c\"\n    checkout main\n    merge foo id: \"Merge branch foo\"</code></pre>"},{"location":"explanation/conventions/#style-de-code","title":"Style de code","text":""},{"location":"explanation/conventions/#conventions-de-nommage","title":"Conventions de nommage","text":"<p>Les conventions de nommage sont celles de la PEP8 :</p> <ul> <li>les classes sont en PascalCase (ex: <code>class SacredGraal</code>)</li> <li>les constantes sont en MACRO_CASE (ex: <code>FAVOURITE_COLOUR = \"blue\"</code>)</li> <li>les fonctions et les variables sont en snake_case (ex: <code>swallow_origin = \"african\"</code>)</li> <li>les fichiers et dossiers contenant du code sont en snake_case</li> <li>les fichiers et les dossiers contenant de la documentation sont en kebab-case</li> </ul> <p>En parall\u00e8le de la casse, certaines r\u00e8gles doivent \u00eatre suivies autant que possible :</p> <ul> <li>un fichier doit contenir une seule classe contenant de la logique ;   on peut y rajouter des classes de donn\u00e9es (<code>Enum</code>, <code>DataClass</code>, <code>pydantic.BaseModel</code>),   tout en prenant garde de ne pas en abuser.</li> <li>le nom d'une classe doit \u00eatre suffix\u00e9 par ce qu'elle repr\u00e9sente :<ul> <li>Les cogs : <code>Cog</code> (<code>RoleCog</code>)</li> <li>les services : <code>Service</code> (<code>UserService</code>)</li> <li>les sch\u00e9mas de donn\u00e9es pydantic : <code>Schema</code> (<code>ApiUserSchema</code>)</li> <li>etc.</li> </ul> </li> <li>les signatures des fonctions doivent syst\u00e9matiquement avoir des annotations de type ;   les variables dont le type n'est pas \u00e9vident doivent aussi \u00eatre annot\u00e9es.</li> </ul> <p>Nous essayons aussi de suivre les conventions de nommage usuelles pour chacun des languages (HTML, CSS et JavaScript) utilis\u00e9s.</p>"},{"location":"explanation/conventions/#format","title":"Format","text":"<p>Le format du code est celui \u00e9tabli par le formateur de Ruff.</p> <p>Vous \u00eates encourag\u00e9s \u00e0 lire la documentation, elle est instructive. Mais elle n'est pas essentielle non plus, puisque Ruff est l\u00e0 pour s'occuper de la question \u00e0 votre place.</p> <p>Retenez simplement :</p> <ul> <li>Si vous faites une PR avec du code qui ne respecte pas le format   attendu, la PR est bloqu\u00e9e.   Pensez bien \u00e0 faire tourner Ruff avant de commit   (ou encore mieux, configurez pre-commit).</li> <li>Si Ruff modifie une partie de votre code et que vous trouvez que le   r\u00e9sultat n'est pas \u00e9l\u00e9gant, alors \u00e7a veut dire que le probl\u00e8me n'est   pas que dans la forme. Profitez-en pour revoir un peu la logique du code.</li> </ul>"},{"location":"explanation/conventions/#qualite-du-code","title":"Qualit\u00e9 du code","text":"<p>Pour s'assurer de la qualit\u00e9 du code, Ruff est \u00e9galement utilis\u00e9.</p> <p>Tout comme pour le format, Ruff doit tourner avant chaque commit.</p> <p>to edit or not to edit</p> <p>Vous constaterez sans doute que <code>ruff format</code> modifie votre code, mais que <code>ruff check</code> vous signale juste une liste d'erreurs sans rien modifier.</p> <p>En effet, <code>ruff format</code> ne s'occupe que de la forme du code, alors que <code>ruff check</code> regarde la logique du code. Si Ruff modifiait automatiquement la logique du code, \u00e7a serait un coup \u00e0 introduire plus de bugs que \u00e7a n'en r\u00e9soud.</p> <p>Il existe cependant certaines cat\u00e9gories d'erreurs que Ruff peut r\u00e9parer de mani\u00e8re s\u00fbre. Pour appliquer ces r\u00e9parations, faites :</p> <pre><code>ruff check --fix\n</code></pre>"},{"location":"explanation/conventions/#documentation","title":"Documentation","text":"<p>La documentation est \u00e9crite en markdown, avec les fonctionnalit\u00e9s offertes par MkDocs, MkDocs-material et leurs extensions.</p> <p>La documentation est int\u00e9gralement en fran\u00e7ais, \u00e0 l'exception des exemples, qui suivent les conventions donn\u00e9es plus haut.</p>"},{"location":"explanation/conventions/#decoupage","title":"D\u00e9coupage","text":"<p>La s\u00e9paration entre les diff\u00e9rentes parties de la documentation se fait en suivant la m\u00e9thodologie Diataxis. On compte quatre sections :</p> <ol> <li>Explications : parlez dans cette section de ce qui est bon \u00e0 savoir    sans que \u00e7a touche aux d\u00e9tails pr\u00e9cis de l'impl\u00e9mentation.    Si vous parlez de pourquoi un choix a \u00e9t\u00e9 fait ou que vous montrez    grossi\u00e8rement les contours d'une partie du projet, c'est une explication.</li> <li>Tutoriels : parlez dans cette section d'\u00e9tapes pr\u00e9cises    ou de d\u00e9tails d'impl\u00e9mentation qu'un nouveau d\u00e9veloppeur    doit suivre pour commencer \u00e0 travailler sur le projet.</li> <li>Utilisation : parlez dans cette section de m\u00e9thodes utiles    pour un d\u00e9veloppeur qui a d\u00e9j\u00e0 pris en main le projet.    Voyez cette partie comme un livre de recettes de cuisine.</li> <li>R\u00e9f\u00e9rence : parlez dans cette section des d\u00e9tails d'impl\u00e9mentation du projet.    En r\u00e9alit\u00e9, vous n'aurez pas besoin de beaucoup vous pencher dessus,    puisque cette partie est compos\u00e9e presque uniquement    des docstrings pr\u00e9sents dans le code.</li> </ol> <p>Pour plus de d\u00e9tails, lisez directement la documentation de Diataxis, qui expose ces concepts de mani\u00e8re beaucoup plus compl\u00e8te.</p>"},{"location":"explanation/conventions/#style","title":"Style","text":"<p>La documentation doit \u00eatre \u00e9crite avec de courts paragraphes. Un maximum de trois phrases par paragraphe est un bon objectif.</p> <p>Votre markdown doit \u00eatre compos\u00e9 de lignes courtes ; \u00e0 partir de 88 caract\u00e8res, c'est trop long. Si une phrase est trop longue pour tenir sur une ligne, vous pouvez l'\u00e9crire sur plusieurs.</p> <p>Une ligne ne peut pas contenir plus d'une seule phrase. Dit autrement, quand vous finissez une phrase, faites syst\u00e9matiquement un saut de ligne.</p> Bien \u2714\ufe0fPas bien \u274c <pre><code>First shalt thou take out the Holy Pin,\nthen shalt thou count to three, no more, no less.\nThree shalt be the number thou shalt count,\nand the number of the counting shalt be three.\nFour shalt thou not count, neither count thou two,\nexcepting that thou then proceed to three.\nFive is right out.\nOnce the number three, being the third number, be reached,\nthen lobbest thou thy Holy Hand Grenade of Antioch towards thou foe,\nwho being naughty in My sight, shall snuff it.\n</code></pre> <pre><code>First shalt thou take out the Holy Pin, then shalt thou count to three, no more, no less. Three shalt be the number thou shalt count, and the number of the counting shalt be three. Four shalt thou not count, neither count thou two, excepting that thou then proceed to three. Five is right out. Once the number three, being the third number, be reached, then lobbest thou thy Holy Hand Grenade of Antioch towards thou foe, who being naughty in My sight, shall snuff it.\n</code></pre> <p>\u00c0 noter que ces deux exemples donnent le m\u00eame r\u00e9sultat dans la documentation g\u00e9n\u00e9r\u00e9e. Mais la version avec des lignes courtes est beaucoup plus facile \u00e0 modifier.</p> <p>Grammaire et orthographe</p> <p>Ca peut paraitre \u00e9vident dit comme \u00e7a, mais c'est toujours bon \u00e0 rappeler : \u00e9vitez de faire des fautes de fran\u00e7ais. Relisez vous quand vous avez fini d'\u00e9crire.</p>"},{"location":"explanation/conventions/#docstrings","title":"Docstrings","text":"<p>Les docstrings sont \u00e9crits en suivant la norme Google et les fonctionnalit\u00e9s de Griffe.</p> <p>Ils doivent \u00eatre explicites sur ce que la fonction accomplit, mais ne pas parler de comment elle le fait. Un bon docstring est celui qui dit exactement ce qu'il faut pour qu'on puisse savoir comment utiliser la fonction ou la classe document\u00e9e sans avoir \u00e0 lire son code.</p> <p>Voyez \u00e7a comme les p\u00e9dales d'une voiture : pour pouvoir conduire, vous avez juste besoin de savoir ce qui se passe quand vous appuyez dessus. La connaissance de la m\u00e9canique interne est inutile dans ce cadre.</p> <p>N'h\u00e9sitez pas \u00e0 mettre des examples dans vos docstrings.</p>"},{"location":"explanation/etu-auth/","title":"Authentification par le site etu","text":"<p>Les membres du serveur Discord peuvent (et doivent !) s'authentifier au moyen de l'API du site \u00e9tu. Cette authentification permet automatiquement :</p> <ul> <li>d'attribuer le pseudo utilis\u00e9 sur le serveur ;   ce dernier est de la forme <code>&lt;pr\u00e9nom&gt; &lt;nom&gt; - &lt;nom de la branche&gt;</code>.</li> <li>d'attribuer les r\u00f4les du membre :<ul> <li>\u00c9tudiant/Ancien \u00e9tudiant/Enseignant</li> <li>S'il est \u00e9tudiant, le(s) r\u00f4le(s) de sa ou ses formations</li> <li>S'il est \u00e9tudiant, ses r\u00f4les d'UE.</li> </ul> </li> </ul> <p>Pseudo Discord</p> <p>Comme un pseudo Discord ne peut faire plus de 32 caract\u00e8res, la s\u00e9lection de celui-ci a quelques subtilit\u00e9s. Pour plus de d\u00e9tails, voir  UserService.get_server_nickname</p>"},{"location":"explanation/etu-auth/#deroulement-de-lauthentification","title":"D\u00e9roulement de l'authentification","text":"<p>Pour l'authentification, plusieurs acteurs sont n\u00e9cessaires :</p> <ul> <li>l'API du site \u00e9tu ; celle-ci fonctionne ind\u00e9pendamment du bot (tant que le site tourne)</li> <li>le serveur du bot ; celui-ci est g\u00e9r\u00e9 par le m\u00eame processus que le bot</li> <li>le bot</li> <li>Et bien s\u00fbr, l'utilisateur</li> </ul> <p>Pour accomplir l'op\u00e9ration, l'utilisateur va se rendre sur un formulaire fourni par le serveur du bot. Le serveur va ensuite interagir avec l'API du site \u00e9tu pour r\u00e9cup\u00e9rer les informations utilisateur puis utiliser les services du bot pour attribuer le pseudo et les r\u00f4les.</p> <pre><code>sequenceDiagram\n    actor User as Membre du serveur\n    participant bot\n    participant server\n    participant api as API du site \u00e9tu\n\n    User-&gt;&gt;server: GET /\n    server-&gt;&gt;api: Redirect /oauth/authorize\n    alt Si l'utilisateur n'est pas encore connect\u00e9\n        api-&gt;&gt;User: Formulaire de connexion\n        User--&gt;&gt;api: POST /user\n    end\n    api--&gt;&gt;server: Code d'autorisation\n    server-&gt;&gt;api: POST /oauth/token\n    api--&gt;&gt;server: token d'acc\u00e8s\n    server-&gt;&gt;User: Formulaire de saisie &lt;br&gt;des infos sur le compte Discord\n    User--&gt;&gt;server: POST /role\n    server-&gt;&gt;api: GET /public/user/account\n    api--&gt;&gt;server: Informations sur l'utilisateur\n    server-&gt;&gt;bot: Transmission des informations\n    bot-&gt;&gt;bot: Attribution des r\u00f4les\n    bot-&gt;&gt;server: R\u00e9sultat de l'attribution\n    server-&gt;&gt;User: Affichage de la page de r\u00e9ussite ou d'une page d'erreur</code></pre>"},{"location":"explanation/technos/","title":"Technologies utilis\u00e9es","text":"<p>Nous tenterons ici d'expliquer les motifs qui ont pouss\u00e9 \u00e0 choisir les technologies utilis\u00e9es dans ce projet.</p> <p>Note</p> <p>Nous n'aborderons ici que les raisons qui ont pouss\u00e9 \u00e0 choisir ces technologies. Si vous cherchez un guide d'installation, veuillez consulter la section Installation.</p>"},{"location":"explanation/technos/#dependances-systeme","title":"D\u00e9pendances syst\u00e8me","text":""},{"location":"explanation/technos/#git-et-github","title":"Git et GitHub","text":"<p>Git est un logiciel de gestion de versions d\u00e9centralis\u00e9. C'est un outil l\u00e9ger, extr\u00eamement puissant et tr\u00e8s r\u00e9pandu. Il est utilis\u00e9 pour g\u00e9rer le code source du projet.</p> <p>GitHub est un service web d'h\u00e9bergement et de gestion de d\u00e9veloppement de logiciels, utilisant le logiciel de gestion de versions Git.</p> <p>Si vous n'\u00eates pas familiers avec Git et GitHub, n'h\u00e9sitez pas \u00e0 chercher des tutoriels sur Internet ; il y en a beaucoup et de tr\u00e8s bonne qualit\u00e9. Si vous ne comprenez pas bien malgr\u00e9 tout, n'h\u00e9sitez pas \u00e0 demander de l'aide \u00e0 un membre du projet ou \u00e0 un membre de l'UNG.</p> <p>Pour faciliter l'usage de Git, vous pouvez \u00e9galement utiliser une interface graphique. Il en existe de tr\u00e8s bons, comme GitKraken, Sublime Merge ou encore l'interface Git int\u00e9gr\u00e9e \u00e0 PyCharm.</p> <p>Tip</p> <p>Git est le standard de facto pour la gestion de version, autant dans le monde de l'entreprise que dans celui du logiciel libre. Si vous ne savez pas encore comment l'utiliser, apprenez. M\u00eame si vous ne comptez pas contribuer au projet, \u00e7a vous sera incroyablement utile.</p>"},{"location":"explanation/technos/#python","title":"Python","text":"<p>Le code est \u00e9crit en Python. C'est un langage simple \u00e0 apprendre et \u00e0 \u00e9crire.</p> <p>Depuis quelques ann\u00e9es, le langage comprend un mod\u00e8le asynchrone qui rend son utilisation tr\u00e8s pertinente dans le cadre d'un bot Discord.</p> <p>Son support croissant pour les indications de type le rendent \u00e9galement de plus en plus expressif, et permettent de concevoir des librairies utilisant le syst\u00e8me de type pour effectuer des conversions et des v\u00e9rifications \u00e0 l'utilisation (ce que Typescript ne permet pas).</p> <p>Signalons aussi que Javascript et Typescript sont d\u00e9j\u00e0 utilis\u00e9s pour la plupart des projets de l'UNG en cours de d\u00e9veloppement. TS eut aussi \u00e9t\u00e9 un choix pertinent, mais c'est bien de varier un peu les technologies utilis\u00e9es.</p>"},{"location":"explanation/technos/#dependances-python","title":"D\u00e9pendances Python","text":""},{"location":"explanation/technos/#discordpy","title":"discord.py","text":"<p>Discord.py est une librairie pour l'\u00e9criture de bots Discord. Elle est facile d'usage, enti\u00e8rement asynchrone et offre un grand nombre de fonctionnalit\u00e9s.</p> <p>Ses performances sont tr\u00e8s bonnes pour du Python : sa conception enti\u00e8rement asynchrone et sa mise en cache des donn\u00e9es lui permettent des temps de r\u00e9ponses tr\u00e8s rapides en utilisant aussi peu d'appels \u00e0 l'API Discord que possible tout en g\u00e9rant le rate limit automatiquement.</p> <p>En outre, les fonctionnalit\u00e9s que la librairie met \u00e0 disposition permettent d'\u00e9crire des commandes concises et lisibles.</p> <p>C'est sans doute la meilleure librairie pour la conception de bots Discord dans l'\u00e9cosyst\u00e8me Python.</p>"},{"location":"explanation/technos/#aiohttp","title":"aiohttp","text":"<p>Pour la connexion depuis le site \u00e9tu, le programme du bot fait tourner en parall\u00e8le un serveur web charg\u00e9 d'int\u00e9ragir avec l'API du site \u00e9tu. Ce serveur tourne avec aiohttp.</p> <p>C'est une librairie qui n'est pas aussi compl\u00e8te que FastAPI, mais elle est tr\u00e8s performante et tr\u00e8s l\u00e9g\u00e8re. C'est une qualit\u00e9 non n\u00e9gligeable, sachant que le serveur web est assez simple (3 routes au total, dont une qui est juste une redirection) et que dans l'id\u00e9al, on veut que l'image Docker du bot soit aussi petite que possible.</p> <p>De plus, discord.py s'appuie sur aiohttp pour faire ses requ\u00eates \u00e0 l'API Discord ainsi qu'\u00e9tablir la connexion Websocket donc la librairie \u00e9tait pr\u00e9sente de toute mani\u00e8re donc autant l'utiliser \u00e0 fond.</p>"},{"location":"explanation/technos/#pydantic","title":"pydantic","text":"<p>Pour la gestion de la configuration et pour parser les requ\u00eates et les r\u00e9ponses du serveur web, on utilise Pydantic.</p> <p>La librairie s'interface extr\u00eamement bien avec les annotations de type de Python. Elle permet une validation des donn\u00e9es intuitive, extr\u00eamement performante et n\u00e9cessitant assez peu de code.</p>"},{"location":"explanation/technos/#qualite-de-code","title":"Qualit\u00e9 de code","text":""},{"location":"explanation/technos/#ruff","title":"Ruff","text":"<p>Ruff est un linter et un formateur de code.</p> <p>Il est extr\u00eamement complet et fiable. Et surtout, sa vitesse d'ex\u00e9cution est absurdement rapide.</p>"},{"location":"explanation/technos/#pre-commit","title":"pre-commit","text":"<p>C'est un framework qui permet d'ajouter des \u00ab hooks \u00bb qui vont s'ex\u00e9cuter automatiquement juste avant de r\u00e9aliser un commit Git. Ceux-ci vont v\u00e9rifier et corriger les fichiers selon la configuration. Il y a notamment le hook de Ruff qui ex\u00e9cute le linter et le formateur.</p>"},{"location":"explanation/technos/#tests","title":"Tests","text":"<p>Dans l'\u00e9cosyst\u00e8me Python, il existe deux m\u00e9thodes principales pour tester un code :</p> <ul> <li><code>unittest</code></li> <li><code>pytest</code></li> </ul> <p>Les deux m\u00e9thodes ont leurs avantages. Et ce projet utilise... ni l'une ni l'autre.</p> <p>En effet, la presque totalit\u00e9 des op\u00e9rations effectu\u00e9es consistent en des manipulations directes du serveur Discord. Et tester ce genre de choses est pratiquement mission impossible.</p> <p>Le projet n'est donc malheureusement pas test\u00e9.</p>"},{"location":"howto/","title":"Utilisation","text":"<p>TODO</p>"},{"location":"reference/commands/admin/","title":"Admin","text":""},{"location":"reference/commands/admin/#etuutt_bot.commands.admin.AdminCog","title":"<code>AdminCog</code>","text":"<p>               Bases: <code>Cog</code></p> <p>Commandes pour les administrateurs du bot.</p> Source code in <code>etuutt_bot/commands/admin.py</code> <pre><code>class AdminCog(commands.Cog):\n    \"\"\"Commandes pour les administrateurs du bot.\"\"\"\n\n    def __init__(self, bot: EtuUTTBot) -&gt; None:\n        self.bot = bot\n\n    @commands.check_any(commands.is_owner(), is_watched_guild_admin())\n    @commands.command(name=\"sync\")\n    async def sync_tree(self, ctx: commands.Context[EtuUTTBot]):\n        \"\"\"Commande pour synchroniser les commandes slash du bot.\n\n        Reserv\u00e9e au propri\u00e9taire et aux membres de l'\u00e9quipe du bot.\n        \"\"\"\n        try:\n            await self.bot.tree.sync()\n            for guild in self.bot.guilds:\n                await self.bot.tree.sync(guild=guild)\n            await ctx.reply(\"Les commandes slash ont bien \u00e9t\u00e9 synchronis\u00e9es.\")\n        except discord.app_commands.CommandSyncFailure as e:\n            self.bot.logger.error(e)\n            await ctx.reply(\n                f\"Il y a eu une erreur lors de la synchronisation des commandes slash\\n{e}\"\n            )\n\n    @commands.Cog.listener()\n    async def on_command_error(\n        self, ctx: commands.Context[EtuUTTBot], error: commands.CommandError\n    ):\n        \"\"\"Gestionnaire d'erreurs des commandes de la classe.\"\"\"\n        if isinstance(error, commands.NotOwner):\n            self.bot.logger.info(f\"{ctx.author}, who isn't authorized, tried to sync the commands\")\n            return\n        self.bot.logger.info(error)\n</code></pre>"},{"location":"reference/commands/admin/#etuutt_bot.commands.admin.AdminCog.on_command_error","title":"<code>on_command_error(ctx, error)</code>  <code>async</code>","text":"<p>Gestionnaire d'erreurs des commandes de la classe.</p> Source code in <code>etuutt_bot/commands/admin.py</code> <pre><code>@commands.Cog.listener()\nasync def on_command_error(\n    self, ctx: commands.Context[EtuUTTBot], error: commands.CommandError\n):\n    \"\"\"Gestionnaire d'erreurs des commandes de la classe.\"\"\"\n    if isinstance(error, commands.NotOwner):\n        self.bot.logger.info(f\"{ctx.author}, who isn't authorized, tried to sync the commands\")\n        return\n    self.bot.logger.info(error)\n</code></pre>"},{"location":"reference/commands/admin/#etuutt_bot.commands.admin.AdminCog.sync_tree","title":"<code>sync_tree(ctx)</code>  <code>async</code>","text":"<p>Commande pour synchroniser les commandes slash du bot.</p> <p>Reserv\u00e9e au propri\u00e9taire et aux membres de l'\u00e9quipe du bot.</p> Source code in <code>etuutt_bot/commands/admin.py</code> <pre><code>@commands.check_any(commands.is_owner(), is_watched_guild_admin())\n@commands.command(name=\"sync\")\nasync def sync_tree(self, ctx: commands.Context[EtuUTTBot]):\n    \"\"\"Commande pour synchroniser les commandes slash du bot.\n\n    Reserv\u00e9e au propri\u00e9taire et aux membres de l'\u00e9quipe du bot.\n    \"\"\"\n    try:\n        await self.bot.tree.sync()\n        for guild in self.bot.guilds:\n            await self.bot.tree.sync(guild=guild)\n        await ctx.reply(\"Les commandes slash ont bien \u00e9t\u00e9 synchronis\u00e9es.\")\n    except discord.app_commands.CommandSyncFailure as e:\n        self.bot.logger.error(e)\n        await ctx.reply(\n            f\"Il y a eu une erreur lors de la synchronisation des commandes slash\\n{e}\"\n        )\n</code></pre>"},{"location":"reference/commands/misc/","title":"Misc","text":""},{"location":"reference/commands/misc/#etuutt_bot.commands.misc.MiscCog","title":"<code>MiscCog</code>","text":"<p>               Bases: <code>Cog</code></p> Source code in <code>etuutt_bot/commands/misc.py</code> <pre><code>class MiscCog(commands.Cog):\n    def __init__(self, bot: EtuUTTBot) -&gt; None:\n        self.bot = bot\n        # Circumvent impossibility to add context menu commands in cogs\n        self.ctx_pin = app_commands.ContextMenu(\n            name=\"\u00c9pingler/D\u00e9s\u00e9pingler\",\n            callback=self.pin,\n        )\n        self.ctx_delete = app_commands.ContextMenu(\n            name=\"Supprimer jusqu'ici\",\n            callback=self.delete,\n        )\n        self.bot.tree.add_command(self.ctx_pin)\n        self.bot.tree.add_command(self.ctx_delete)\n\n    async def cog_unload(self) -&gt; None:\n        self.bot.tree.remove_command(self.ctx_pin.name, type=self.ctx_pin.type)\n        self.bot.tree.remove_command(self.ctx_delete.name, type=self.ctx_delete.type)\n\n    # Simple ping command\n    @app_commands.command(name=\"ping\", description=\"Teste le ping du bot\")\n    async def ping(self, interaction: discord.Interaction[EtuUTTBot]):\n        await interaction.response.send_message(\n            f\"Pong! En {round(interaction.client.latency * 1000)}ms\"\n        )\n\n    # Make a simple context menu application to pin/unpin\n    @app_commands.guild_only\n    @app_commands.default_permissions(send_messages=True)\n    @app_commands.checks.has_permissions(send_messages=True)\n    @app_commands.checks.bot_has_permissions(manage_messages=True)\n    async def pin(self, interaction: discord.Interaction[EtuUTTBot], message: discord.Message):\n        if message.pinned:\n            await message.unpin()\n            await interaction.response.send_message(\n                \"Le message a \u00e9t\u00e9 d\u00e9s\u00e9pingl\u00e9 !\", ephemeral=True\n            )\n        else:\n            await message.pin()\n            await interaction.response.send_message(\"Le message a \u00e9t\u00e9 \u00e9pingl\u00e9 !\", ephemeral=True)\n\n    # Make a context menu command to delete messages\n    @app_commands.guild_only\n    @app_commands.default_permissions(manage_messages=True)\n    @app_commands.checks.has_permissions(manage_messages=True)\n    @app_commands.checks.bot_has_permissions(\n        manage_messages=True, read_message_history=True, read_messages=True\n    )\n    async def delete(self, interaction: discord.Interaction[EtuUTTBot], message: discord.Message):\n        await interaction.response.defer(ephemeral=True, thinking=True)\n\n        del_msg = await message.channel.purge(\n            bulk=True,\n            reason=\"Admin used bulk delete\",\n            # Timedelta to include the selected message in the bulk delete\n            after=(message.created_at - timedelta(milliseconds=1)),\n        )\n        await interaction.followup.send(f\"{len(del_msg)} messages supprim\u00e9s !\")\n</code></pre>"},{"location":"reference/commands/role/","title":"Role","text":""},{"location":"reference/commands/role/#etuutt_bot.commands.role.RoleCog","title":"<code>RoleCog</code>","text":"<p>               Bases: <code>GroupCog</code></p> <p>Commandes li\u00e9es \u00e0 la gestion des r\u00f4les</p> Source code in <code>etuutt_bot/commands/role.py</code> <pre><code>@app_commands.default_permissions(administrator=True)\nclass RoleCog(commands.GroupCog, group_name=\"role\"):\n    \"\"\"Commandes li\u00e9es \u00e0 la gestion des r\u00f4les\"\"\"\n\n    def __init__(self, bot: EtuUTTBot) -&gt; None:\n        self.bot = bot\n        self.channel_service = ChannelService(bot)\n        self.role_service = RoleService(bot)\n\n    @app_commands.command(name=\"between\")\n    async def get_roles_with_framed_number_of_members(\n        self, interaction: Interaction[EtuUTTBot], nb_min: int = 0, nb_max: int = 1\n    ):\n        \"\"\"Affiche les r\u00f4les ayant plus de nb_min et moins de nb_max personnes dedans.\n\n        Args:\n            interaction:\n            nb_min: Le nombre de personnes minimum ayant le r\u00f4le (par d\u00e9faut : 0)\n            nb_max: Le nombre de personnes maximum ayant le r\u00f4le (par d\u00e9faut : 1)\n        \"\"\"\n        await interaction.response.defer(thinking=True)\n        if nb_min &gt; nb_max:\n            await interaction.followup.send(\"Erreur : nb_min doit \u00eatre inf\u00e9rieur ou \u00e9gal \u00e0 nb_max\")\n            return\n        roles = [r for r in interaction.guild.roles if nb_min &lt;= len(r.members) &lt;= nb_max]\n        if len(roles) == 0:\n            await interaction.followup.send(\n                \"\\N{WHITE HEAVY CHECK MARK} Commande termin\u00e9e, aucun r\u00f4le n'a \u00e9t\u00e9 identifi\u00e9.\"\n            )\n            return\n        if len(roles) == 1:\n            await interaction.followup.send(\n                \"\\N{WHITE HEAVY CHECK MARK} Commande termin\u00e9e, un r\u00f4le trouv\u00e9 : \"\n                f\"{roles[0].name} avec {len(roles[0].members)} membres\"\n            )\n            return\n        msg = f\"\\N{WHITE HEAVY CHECK MARK} Commande termin\u00e9e, {len(roles)} r\u00f4les trouv\u00e9s : \"\n        # group roles by ascending number of members\n        # start by sorting the roles in order to make the operation\n        # O(log(n) + n) instead of O(n\u00b2)\n        grouped_roles = groupby(\n            sorted(roles, key=lambda r: len(r.members)), key=lambda r: len(r.members)\n        )\n        for nb_members, roles_group in grouped_roles:\n            msg += f\"\\n## R\u00f4les avec {nb_members} membres :\\n\"\n            msg += \"\\n\".join(f\"- {r.name}\" for r in roles_group)\n        chunks = list(split_msg(msg))\n        for chunk in chunks[1:]:\n            await interaction.channel.send(chunk)\n        # send the last part of the message as a followup\n        # to remove the \"thinking\" message\n        await interaction.followup.send(chunks[0])\n\n    # Remove all users from a role\n    @app_commands.checks.bot_has_permissions(manage_roles=True)\n    @app_commands.command(name=\"removeall\")\n    async def remove_all(self, interaction: Interaction[EtuUTTBot], role: discord.Role):\n        \"\"\"Prend toutes les personnes ayant le r\u00f4le et leur retire.\n\n        Args:\n            interaction:\n            role: le r\u00f4le auquel qu'on veut retirer \u00e0 tout le monde\n        \"\"\"\n        await interaction.response.defer(thinking=True)\n        for member in role.members:\n            await member.remove_roles(role)\n        await interaction.followup.send(\n            f\"\\N{WHITE HEAVY CHECK MARK} Plus personne n'a le r\u00f4le {role.name}\"\n        )\n\n    @app_commands.command(name=\"get_duplicates\")\n    async def get_duplicates(\n        self, interaction: Interaction[EtuUTTBot], case_sensitive: bool = False\n    ):\n        \"\"\"Affiche tous les r\u00f4les qui sont dupliqu\u00e9s.\n\n        On consid\u00e8re que deux r\u00f4les sont dupliqu\u00e9s quand ils ont le m\u00eame nom.\n\n        Args:\n            interaction:\n            case_sensitive: La casse est-elle prise en compte dans la recherche des duplications ?\n        \"\"\"\n        await interaction.response.defer(thinking=True)\n        duplicates = self.role_service.get_duplicates(case_sensitive=case_sensitive)\n        if not duplicates:\n            await interaction.followup.send(\"Aucun r\u00f4le dupliqu\u00e9 \\N{THUMBS UP SIGN}\")\n            return\n        message = f\"{len(duplicates)} r\u00f4les dupliqu\u00e9s :\\n\"\n        message += \"\\n\".join(\n            f\"- **{d[0].name}**. Nombre de duplications : {len(d)}\" for d in duplicates\n        )\n        await interaction.followup.send(message)\n\n    @app_commands.command(name=\"merge\")\n    @app_commands.choices()\n    async def merge_roles(\n        self,\n        interaction: Interaction[EtuUTTBot],\n        role: discord.Role,\n        case_sensitive: bool = True,\n        merge_strategy: MergeStrategy = MergeStrategy.Intersection,\n    ):\n        \"\"\"Fusionne en un seul tous les r\u00f4les ayant le m\u00eame nom que le r\u00f4le donn\u00e9.\n\n        Args:\n            interaction:\n            role: Le r\u00f4le qu'on veut fusionner avec tous ceux qui ont le m\u00eame nom.\n            case_sensitive: La casse est-elle prise en compte dans la recherche des duplications ?\n            merge_strategy: La mani\u00e8re de fusionner les permissions associ\u00e9es aux r\u00f4les fusionn\u00e9es.\n\n                - Si `Union`, toutes les permissions sont gard\u00e9es.\n                - Si `Intersection`, seules les permissions communes \u00e0 tous les r\u00f4les sont gard\u00e9es.\n                - Si `Clear`, aucune permission n'est gard\u00e9e.\n        \"\"\"\n        await interaction.response.defer(thinking=True)\n        duplicates = self.role_service.get_duplicate(role, case_sensitive=case_sensitive)\n        nb_duplicates = len(duplicates)\n        if nb_duplicates &lt; 2:\n            await interaction.followup.send(\n                \"Ce r\u00f4le n'est pas dupliqu\u00e9 \\N{THINKING FACE}\\n\"\n                \"Utilisez la commande `get_duplicates` pour voir quels r\u00f4les sont dupliqu\u00e9s\"\n            )\n            return\n        await self.role_service.merge(duplicates, merge_perms_strategy=merge_strategy)\n        await interaction.followup.send(\n            f\"Commande finie. {nb_duplicates} r\u00f4les fusionn\u00e9s. \\N{THUMBS UP SIGN}\"\n        )\n</code></pre>"},{"location":"reference/commands/role/#etuutt_bot.commands.role.RoleCog.get_duplicates","title":"<code>get_duplicates(interaction, case_sensitive=False)</code>  <code>async</code>","text":"<p>Affiche tous les r\u00f4les qui sont dupliqu\u00e9s.</p> <p>On consid\u00e8re que deux r\u00f4les sont dupliqu\u00e9s quand ils ont le m\u00eame nom.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction[EtuUTTBot]</code> required <code>case_sensitive</code> <code>bool</code> <p>La casse est-elle prise en compte dans la recherche des duplications ?</p> <code>False</code> Source code in <code>etuutt_bot/commands/role.py</code> <pre><code>@app_commands.command(name=\"get_duplicates\")\nasync def get_duplicates(\n    self, interaction: Interaction[EtuUTTBot], case_sensitive: bool = False\n):\n    \"\"\"Affiche tous les r\u00f4les qui sont dupliqu\u00e9s.\n\n    On consid\u00e8re que deux r\u00f4les sont dupliqu\u00e9s quand ils ont le m\u00eame nom.\n\n    Args:\n        interaction:\n        case_sensitive: La casse est-elle prise en compte dans la recherche des duplications ?\n    \"\"\"\n    await interaction.response.defer(thinking=True)\n    duplicates = self.role_service.get_duplicates(case_sensitive=case_sensitive)\n    if not duplicates:\n        await interaction.followup.send(\"Aucun r\u00f4le dupliqu\u00e9 \\N{THUMBS UP SIGN}\")\n        return\n    message = f\"{len(duplicates)} r\u00f4les dupliqu\u00e9s :\\n\"\n    message += \"\\n\".join(\n        f\"- **{d[0].name}**. Nombre de duplications : {len(d)}\" for d in duplicates\n    )\n    await interaction.followup.send(message)\n</code></pre>"},{"location":"reference/commands/role/#etuutt_bot.commands.role.RoleCog.get_roles_with_framed_number_of_members","title":"<code>get_roles_with_framed_number_of_members(interaction, nb_min=0, nb_max=1)</code>  <code>async</code>","text":"<p>Affiche les r\u00f4les ayant plus de nb_min et moins de nb_max personnes dedans.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction[EtuUTTBot]</code> required <code>nb_min</code> <code>int</code> <p>Le nombre de personnes minimum ayant le r\u00f4le (par d\u00e9faut : 0)</p> <code>0</code> <code>nb_max</code> <code>int</code> <p>Le nombre de personnes maximum ayant le r\u00f4le (par d\u00e9faut : 1)</p> <code>1</code> Source code in <code>etuutt_bot/commands/role.py</code> <pre><code>@app_commands.command(name=\"between\")\nasync def get_roles_with_framed_number_of_members(\n    self, interaction: Interaction[EtuUTTBot], nb_min: int = 0, nb_max: int = 1\n):\n    \"\"\"Affiche les r\u00f4les ayant plus de nb_min et moins de nb_max personnes dedans.\n\n    Args:\n        interaction:\n        nb_min: Le nombre de personnes minimum ayant le r\u00f4le (par d\u00e9faut : 0)\n        nb_max: Le nombre de personnes maximum ayant le r\u00f4le (par d\u00e9faut : 1)\n    \"\"\"\n    await interaction.response.defer(thinking=True)\n    if nb_min &gt; nb_max:\n        await interaction.followup.send(\"Erreur : nb_min doit \u00eatre inf\u00e9rieur ou \u00e9gal \u00e0 nb_max\")\n        return\n    roles = [r for r in interaction.guild.roles if nb_min &lt;= len(r.members) &lt;= nb_max]\n    if len(roles) == 0:\n        await interaction.followup.send(\n            \"\\N{WHITE HEAVY CHECK MARK} Commande termin\u00e9e, aucun r\u00f4le n'a \u00e9t\u00e9 identifi\u00e9.\"\n        )\n        return\n    if len(roles) == 1:\n        await interaction.followup.send(\n            \"\\N{WHITE HEAVY CHECK MARK} Commande termin\u00e9e, un r\u00f4le trouv\u00e9 : \"\n            f\"{roles[0].name} avec {len(roles[0].members)} membres\"\n        )\n        return\n    msg = f\"\\N{WHITE HEAVY CHECK MARK} Commande termin\u00e9e, {len(roles)} r\u00f4les trouv\u00e9s : \"\n    # group roles by ascending number of members\n    # start by sorting the roles in order to make the operation\n    # O(log(n) + n) instead of O(n\u00b2)\n    grouped_roles = groupby(\n        sorted(roles, key=lambda r: len(r.members)), key=lambda r: len(r.members)\n    )\n    for nb_members, roles_group in grouped_roles:\n        msg += f\"\\n## R\u00f4les avec {nb_members} membres :\\n\"\n        msg += \"\\n\".join(f\"- {r.name}\" for r in roles_group)\n    chunks = list(split_msg(msg))\n    for chunk in chunks[1:]:\n        await interaction.channel.send(chunk)\n    # send the last part of the message as a followup\n    # to remove the \"thinking\" message\n    await interaction.followup.send(chunks[0])\n</code></pre>"},{"location":"reference/commands/role/#etuutt_bot.commands.role.RoleCog.merge_roles","title":"<code>merge_roles(interaction, role, case_sensitive=True, merge_strategy=MergeStrategy.Intersection)</code>  <code>async</code>","text":"<p>Fusionne en un seul tous les r\u00f4les ayant le m\u00eame nom que le r\u00f4le donn\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction[EtuUTTBot]</code> required <code>role</code> <code>Role</code> <p>Le r\u00f4le qu'on veut fusionner avec tous ceux qui ont le m\u00eame nom.</p> required <code>case_sensitive</code> <code>bool</code> <p>La casse est-elle prise en compte dans la recherche des duplications ?</p> <code>True</code> <code>merge_strategy</code> <code>MergeStrategy</code> <p>La mani\u00e8re de fusionner les permissions associ\u00e9es aux r\u00f4les fusionn\u00e9es.</p> <ul> <li>Si <code>Union</code>, toutes les permissions sont gard\u00e9es.</li> <li>Si <code>Intersection</code>, seules les permissions communes \u00e0 tous les r\u00f4les sont gard\u00e9es.</li> <li>Si <code>Clear</code>, aucune permission n'est gard\u00e9e.</li> </ul> <code>Intersection</code> Source code in <code>etuutt_bot/commands/role.py</code> <pre><code>@app_commands.command(name=\"merge\")\n@app_commands.choices()\nasync def merge_roles(\n    self,\n    interaction: Interaction[EtuUTTBot],\n    role: discord.Role,\n    case_sensitive: bool = True,\n    merge_strategy: MergeStrategy = MergeStrategy.Intersection,\n):\n    \"\"\"Fusionne en un seul tous les r\u00f4les ayant le m\u00eame nom que le r\u00f4le donn\u00e9.\n\n    Args:\n        interaction:\n        role: Le r\u00f4le qu'on veut fusionner avec tous ceux qui ont le m\u00eame nom.\n        case_sensitive: La casse est-elle prise en compte dans la recherche des duplications ?\n        merge_strategy: La mani\u00e8re de fusionner les permissions associ\u00e9es aux r\u00f4les fusionn\u00e9es.\n\n            - Si `Union`, toutes les permissions sont gard\u00e9es.\n            - Si `Intersection`, seules les permissions communes \u00e0 tous les r\u00f4les sont gard\u00e9es.\n            - Si `Clear`, aucune permission n'est gard\u00e9e.\n    \"\"\"\n    await interaction.response.defer(thinking=True)\n    duplicates = self.role_service.get_duplicate(role, case_sensitive=case_sensitive)\n    nb_duplicates = len(duplicates)\n    if nb_duplicates &lt; 2:\n        await interaction.followup.send(\n            \"Ce r\u00f4le n'est pas dupliqu\u00e9 \\N{THINKING FACE}\\n\"\n            \"Utilisez la commande `get_duplicates` pour voir quels r\u00f4les sont dupliqu\u00e9s\"\n        )\n        return\n    await self.role_service.merge(duplicates, merge_perms_strategy=merge_strategy)\n    await interaction.followup.send(\n        f\"Commande finie. {nb_duplicates} r\u00f4les fusionn\u00e9s. \\N{THUMBS UP SIGN}\"\n    )\n</code></pre>"},{"location":"reference/commands/role/#etuutt_bot.commands.role.RoleCog.remove_all","title":"<code>remove_all(interaction, role)</code>  <code>async</code>","text":"<p>Prend toutes les personnes ayant le r\u00f4le et leur retire.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction[EtuUTTBot]</code> required <code>role</code> <code>Role</code> <p>le r\u00f4le auquel qu'on veut retirer \u00e0 tout le monde</p> required Source code in <code>etuutt_bot/commands/role.py</code> <pre><code>@app_commands.checks.bot_has_permissions(manage_roles=True)\n@app_commands.command(name=\"removeall\")\nasync def remove_all(self, interaction: Interaction[EtuUTTBot], role: discord.Role):\n    \"\"\"Prend toutes les personnes ayant le r\u00f4le et leur retire.\n\n    Args:\n        interaction:\n        role: le r\u00f4le auquel qu'on veut retirer \u00e0 tout le monde\n    \"\"\"\n    await interaction.response.defer(thinking=True)\n    for member in role.members:\n        await member.remove_roles(role)\n    await interaction.followup.send(\n        f\"\\N{WHITE HEAVY CHECK MARK} Plus personne n'a le r\u00f4le {role.name}\"\n    )\n</code></pre>"},{"location":"reference/commands/ue/","title":"Ue","text":""},{"location":"reference/commands/ue/#etuutt_bot.commands.ue.UeCog","title":"<code>UeCog</code>","text":"<p>               Bases: <code>GroupCog</code></p> <p>Commandes li\u00e9es \u00e0 la gestion des UEs.</p> Source code in <code>etuutt_bot/commands/ue.py</code> <pre><code>@app_commands.default_permissions(administrator=True)\nclass UeCog(commands.GroupCog, group_name=\"ues\"):\n    \"\"\"Commandes li\u00e9es \u00e0 la gestion des UEs.\"\"\"\n\n    def __init__(self, bot: EtuUTTBot):\n        self.bot = bot\n        self.ue_service = UeService(bot)\n\n    @app_commands.checks.bot_has_permissions(manage_channels=True, manage_roles=True)\n    @app_commands.command(name=\"add_all\")\n    async def add_category(self, interaction: Interaction[EtuUTTBot], category: CategoryChannel):\n        \"\"\"Cr\u00e9e les salons textuels et les r\u00f4les pour toutes les UEs d'une cat\u00e9gorie.\n\n        Args:\n            interaction:\n            category: La cat\u00e9gorie dans laquelle on veut cr\u00e9er les salons d'UE\n        \"\"\"\n        await interaction.response.defer(thinking=True)\n        settings_cat = next(\n            (cat for cat in self.bot.settings.categories if cat.id == category.id), None\n        )\n        if settings_cat is None:\n            await interaction.followup.send(\n                f\"La cat\u00e9gorie {category.name} n'est pas destin\u00e9e \u00e0 accueillir des salons d'UE\"\n            )\n            return\n        ues_names = {ue.lower() for ue in settings_cat.ues}\n        msg = \"\"\n\n        # Ensure that channels don't exist yet in order not to overwrite them\n        to_create = self.ue_service.get_missing_channels(category)\n        if len(to_create) &lt; len(settings_cat.ues):\n            msg += \"\\n## \\N{SLEEPING SYMBOL} Les salons suivants existent d\u00e9j\u00e0 :\\n\"\n            msg += \"\\n\".join(f\"- {c}\" for c in ues_names - to_create)\n\n        if len(to_create) &gt; 0:\n            msg += \"\\n## Salons textuels cr\u00e9\u00e9s :\\n\"\n            for channel_name in to_create:\n                channel, role = await self.ue_service.create_channel(channel_name)\n                await channel.send(\n                    f\"{role.mention} votre salon vient d'\u00eatre cr\u00e9\u00e9 \\N{WAVING HAND SIGN}\"\n                )\n                msg += f\"\\n- {channel.name}\"\n\n        for chunk in split_msg(msg):\n            await interaction.channel.send(chunk)\n        await interaction.followup.send(\"\\N{WHITE HEAVY CHECK MARK} La commande est termin\u00e9e :\")\n\n    @app_commands.checks.bot_has_permissions(manage_channels=True, manage_roles=True)\n    @app_commands.command(name=\"add\")\n    async def add_one(self, interaction: Interaction[EtuUTTBot], ue: str):\n        \"\"\"Cr\u00e9e le salon correspondant \u00e0 l'UE donn\u00e9e.\n\n        Args:\n            interaction:\n            ue: le nom de l'UE \u00e0 cr\u00e9er\n        \"\"\"\n        await interaction.response.defer(thinking=True)\n        try:\n            channel, role = await self.ue_service.create_channel(ue)\n        except AlreadyExistsError:\n            await interaction.followup.send(\"Ce salon existe d\u00e9j\u00e0.\")\n            return\n        except MissingConfigurationError:\n            await interaction.followup.send(\n                \"Cette UE n'a pas \u00e9t\u00e9 trouv\u00e9e dans la configuration du bot.\\n\"\n                \"Vous avez peut-\u00eatre fait une faute de frappe, \"\n                \"ou bien la configuration du bot n'est pas \u00e0 jour avec le catalogue des UEs.\"\n            )\n            return\n        except CategoryMissingError:\n            await interaction.followup.send(\n                \"La cat\u00e9gorie pour cette UE n'existe pas \"\n                \"ou l'ID est incorrect dans la configuration.\"\n            )\n            return\n        await channel.send(f\"{role.mention} votre salon vient d'\u00eatre cr\u00e9\u00e9 \\N{WAVING HAND SIGN}\")\n        await interaction.followup.send(\"Salon cr\u00e9\u00e9 \\N{THUMBS UP SIGN}\")\n\n    @app_commands.checks.bot_has_permissions(manage_channels=True, manage_roles=True)\n    @app_commands.command(name=\"remove_all\")\n    async def delete_many(\n        self,\n        interaction: Interaction[EtuUTTBot],\n        category: CategoryChannel,\n        delete_roles: bool = True,\n    ):\n        \"\"\"Supprime les salons de toutes les UEs de la cat\u00e9gorie donn\u00e9e.\n\n        Args:\n            category: la cat\u00e9gorie dans laquelle supprimer tous les salons d'UE\n            delete_roles: si `True`, les r\u00f4les associ\u00e9s aux UEs sont \u00e9galement supprim\u00e9s\n        \"\"\"\n        await interaction.response.defer(thinking=True)\n        nb_deleted = await self.ue_service.delete_all_channels(category, delete_roles=delete_roles)\n        await interaction.followup.send(f\"Commande finie. {nb_deleted} salons supprim\u00e9s.\")\n\n    @app_commands.checks.bot_has_permissions(manage_channels=True, manage_roles=True)\n    @app_commands.command(name=\"remove\")\n    async def delete_one(\n        self,\n        interaction: Interaction[EtuUTTBot],\n        channel: TextChannel,\n        delete_role: bool = True,\n    ):\n        \"\"\"Supprime le salon d'UE donn\u00e9.\n\n        Args:\n            channel: le salon d'UE \u00e0 supprimer\n            delete_role: si `True`, le r\u00f4le associ\u00e9 \u00e0 l'UE sont \u00e9galement supprim\u00e9s\n        \"\"\"\n        await interaction.response.defer(thinking=True)\n        await self.ue_service.delete_channel(channel, delete_role=delete_role)\n        await interaction.followup.send(\"Commande finie. Salon supprim\u00e9.\")\n\n    @add_one.autocomplete(\"ue\")\n    async def autocomplete_missing_ue(self, interaction: Interaction[EtuUTTBot], current: str):\n        \"\"\"Autocompl\u00e9tion pour les ues dont le salon n'existe pas.\n\n        Comme le but de cette autocompl\u00e9tion est de sugg\u00e9rer\n        des noms de salons qui n'ont *pas encore* \u00e9t\u00e9 cr\u00e9\u00e9s et pour\n        lesquels il n'existe *pas encore* forc\u00e9ment de r\u00f4le,\n        on ne peut pas utiliser les fonctions d'autocompl\u00e9tion par d\u00e9faut.\n        \"\"\"\n        ues = self.ue_service.get_missing_channels()\n        return [app_commands.Choice(name=ue, value=ue) for ue in ues if current.lower() in ue]\n</code></pre>"},{"location":"reference/commands/ue/#etuutt_bot.commands.ue.UeCog.add_category","title":"<code>add_category(interaction, category)</code>  <code>async</code>","text":"<p>Cr\u00e9e les salons textuels et les r\u00f4les pour toutes les UEs d'une cat\u00e9gorie.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction[EtuUTTBot]</code> required <code>category</code> <code>CategoryChannel</code> <p>La cat\u00e9gorie dans laquelle on veut cr\u00e9er les salons d'UE</p> required Source code in <code>etuutt_bot/commands/ue.py</code> <pre><code>@app_commands.checks.bot_has_permissions(manage_channels=True, manage_roles=True)\n@app_commands.command(name=\"add_all\")\nasync def add_category(self, interaction: Interaction[EtuUTTBot], category: CategoryChannel):\n    \"\"\"Cr\u00e9e les salons textuels et les r\u00f4les pour toutes les UEs d'une cat\u00e9gorie.\n\n    Args:\n        interaction:\n        category: La cat\u00e9gorie dans laquelle on veut cr\u00e9er les salons d'UE\n    \"\"\"\n    await interaction.response.defer(thinking=True)\n    settings_cat = next(\n        (cat for cat in self.bot.settings.categories if cat.id == category.id), None\n    )\n    if settings_cat is None:\n        await interaction.followup.send(\n            f\"La cat\u00e9gorie {category.name} n'est pas destin\u00e9e \u00e0 accueillir des salons d'UE\"\n        )\n        return\n    ues_names = {ue.lower() for ue in settings_cat.ues}\n    msg = \"\"\n\n    # Ensure that channels don't exist yet in order not to overwrite them\n    to_create = self.ue_service.get_missing_channels(category)\n    if len(to_create) &lt; len(settings_cat.ues):\n        msg += \"\\n## \\N{SLEEPING SYMBOL} Les salons suivants existent d\u00e9j\u00e0 :\\n\"\n        msg += \"\\n\".join(f\"- {c}\" for c in ues_names - to_create)\n\n    if len(to_create) &gt; 0:\n        msg += \"\\n## Salons textuels cr\u00e9\u00e9s :\\n\"\n        for channel_name in to_create:\n            channel, role = await self.ue_service.create_channel(channel_name)\n            await channel.send(\n                f\"{role.mention} votre salon vient d'\u00eatre cr\u00e9\u00e9 \\N{WAVING HAND SIGN}\"\n            )\n            msg += f\"\\n- {channel.name}\"\n\n    for chunk in split_msg(msg):\n        await interaction.channel.send(chunk)\n    await interaction.followup.send(\"\\N{WHITE HEAVY CHECK MARK} La commande est termin\u00e9e :\")\n</code></pre>"},{"location":"reference/commands/ue/#etuutt_bot.commands.ue.UeCog.add_one","title":"<code>add_one(interaction, ue)</code>  <code>async</code>","text":"<p>Cr\u00e9e le salon correspondant \u00e0 l'UE donn\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>Interaction[EtuUTTBot]</code> required <code>ue</code> <code>str</code> <p>le nom de l'UE \u00e0 cr\u00e9er</p> required Source code in <code>etuutt_bot/commands/ue.py</code> <pre><code>@app_commands.checks.bot_has_permissions(manage_channels=True, manage_roles=True)\n@app_commands.command(name=\"add\")\nasync def add_one(self, interaction: Interaction[EtuUTTBot], ue: str):\n    \"\"\"Cr\u00e9e le salon correspondant \u00e0 l'UE donn\u00e9e.\n\n    Args:\n        interaction:\n        ue: le nom de l'UE \u00e0 cr\u00e9er\n    \"\"\"\n    await interaction.response.defer(thinking=True)\n    try:\n        channel, role = await self.ue_service.create_channel(ue)\n    except AlreadyExistsError:\n        await interaction.followup.send(\"Ce salon existe d\u00e9j\u00e0.\")\n        return\n    except MissingConfigurationError:\n        await interaction.followup.send(\n            \"Cette UE n'a pas \u00e9t\u00e9 trouv\u00e9e dans la configuration du bot.\\n\"\n            \"Vous avez peut-\u00eatre fait une faute de frappe, \"\n            \"ou bien la configuration du bot n'est pas \u00e0 jour avec le catalogue des UEs.\"\n        )\n        return\n    except CategoryMissingError:\n        await interaction.followup.send(\n            \"La cat\u00e9gorie pour cette UE n'existe pas \"\n            \"ou l'ID est incorrect dans la configuration.\"\n        )\n        return\n    await channel.send(f\"{role.mention} votre salon vient d'\u00eatre cr\u00e9\u00e9 \\N{WAVING HAND SIGN}\")\n    await interaction.followup.send(\"Salon cr\u00e9\u00e9 \\N{THUMBS UP SIGN}\")\n</code></pre>"},{"location":"reference/commands/ue/#etuutt_bot.commands.ue.UeCog.autocomplete_missing_ue","title":"<code>autocomplete_missing_ue(interaction, current)</code>  <code>async</code>","text":"<p>Autocompl\u00e9tion pour les ues dont le salon n'existe pas.</p> <p>Comme le but de cette autocompl\u00e9tion est de sugg\u00e9rer des noms de salons qui n'ont pas encore \u00e9t\u00e9 cr\u00e9\u00e9s et pour lesquels il n'existe pas encore forc\u00e9ment de r\u00f4le, on ne peut pas utiliser les fonctions d'autocompl\u00e9tion par d\u00e9faut.</p> Source code in <code>etuutt_bot/commands/ue.py</code> <pre><code>@add_one.autocomplete(\"ue\")\nasync def autocomplete_missing_ue(self, interaction: Interaction[EtuUTTBot], current: str):\n    \"\"\"Autocompl\u00e9tion pour les ues dont le salon n'existe pas.\n\n    Comme le but de cette autocompl\u00e9tion est de sugg\u00e9rer\n    des noms de salons qui n'ont *pas encore* \u00e9t\u00e9 cr\u00e9\u00e9s et pour\n    lesquels il n'existe *pas encore* forc\u00e9ment de r\u00f4le,\n    on ne peut pas utiliser les fonctions d'autocompl\u00e9tion par d\u00e9faut.\n    \"\"\"\n    ues = self.ue_service.get_missing_channels()\n    return [app_commands.Choice(name=ue, value=ue) for ue in ues if current.lower() in ue]\n</code></pre>"},{"location":"reference/commands/ue/#etuutt_bot.commands.ue.UeCog.delete_many","title":"<code>delete_many(interaction, category, delete_roles=True)</code>  <code>async</code>","text":"<p>Supprime les salons de toutes les UEs de la cat\u00e9gorie donn\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>CategoryChannel</code> <p>la cat\u00e9gorie dans laquelle supprimer tous les salons d'UE</p> required <code>delete_roles</code> <code>bool</code> <p>si <code>True</code>, les r\u00f4les associ\u00e9s aux UEs sont \u00e9galement supprim\u00e9s</p> <code>True</code> Source code in <code>etuutt_bot/commands/ue.py</code> <pre><code>@app_commands.checks.bot_has_permissions(manage_channels=True, manage_roles=True)\n@app_commands.command(name=\"remove_all\")\nasync def delete_many(\n    self,\n    interaction: Interaction[EtuUTTBot],\n    category: CategoryChannel,\n    delete_roles: bool = True,\n):\n    \"\"\"Supprime les salons de toutes les UEs de la cat\u00e9gorie donn\u00e9e.\n\n    Args:\n        category: la cat\u00e9gorie dans laquelle supprimer tous les salons d'UE\n        delete_roles: si `True`, les r\u00f4les associ\u00e9s aux UEs sont \u00e9galement supprim\u00e9s\n    \"\"\"\n    await interaction.response.defer(thinking=True)\n    nb_deleted = await self.ue_service.delete_all_channels(category, delete_roles=delete_roles)\n    await interaction.followup.send(f\"Commande finie. {nb_deleted} salons supprim\u00e9s.\")\n</code></pre>"},{"location":"reference/commands/ue/#etuutt_bot.commands.ue.UeCog.delete_one","title":"<code>delete_one(interaction, channel, delete_role=True)</code>  <code>async</code>","text":"<p>Supprime le salon d'UE donn\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>TextChannel</code> <p>le salon d'UE \u00e0 supprimer</p> required <code>delete_role</code> <code>bool</code> <p>si <code>True</code>, le r\u00f4le associ\u00e9 \u00e0 l'UE sont \u00e9galement supprim\u00e9s</p> <code>True</code> Source code in <code>etuutt_bot/commands/ue.py</code> <pre><code>@app_commands.checks.bot_has_permissions(manage_channels=True, manage_roles=True)\n@app_commands.command(name=\"remove\")\nasync def delete_one(\n    self,\n    interaction: Interaction[EtuUTTBot],\n    channel: TextChannel,\n    delete_role: bool = True,\n):\n    \"\"\"Supprime le salon d'UE donn\u00e9.\n\n    Args:\n        channel: le salon d'UE \u00e0 supprimer\n        delete_role: si `True`, le r\u00f4le associ\u00e9 \u00e0 l'UE sont \u00e9galement supprim\u00e9s\n    \"\"\"\n    await interaction.response.defer(thinking=True)\n    await self.ue_service.delete_channel(channel, delete_role=delete_role)\n    await interaction.followup.send(\"Commande finie. Salon supprim\u00e9.\")\n</code></pre>"},{"location":"reference/services/channel/","title":"Channel","text":""},{"location":"reference/services/channel/#etuutt_bot.services.channel.ChannelService","title":"<code>ChannelService</code>","text":"Source code in <code>etuutt_bot/services/channel.py</code> <pre><code>class ChannelService:\n    def __init__(self, bot: EtuUTTBot):\n        self._bot = bot\n\n    def find_by_name(\n        self, name: str, *, channel_type: type[AnyChannel] | None = None\n    ) -&gt; AnyChannel:\n        name = name.lower()\n        channels = self._bot.watched_guild.channels\n        if channel_type:\n            channels = (c for c in channels if isinstance(c, channel_type))\n        return next((c for c in channels if c.name == name), None)\n</code></pre>"},{"location":"reference/services/role/","title":"Role","text":""},{"location":"reference/services/role/#etuutt_bot.services.role.MergeStrategy","title":"<code>MergeStrategy</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Strat\u00e9gie pour la fusion de plusieurs objets.</p> Source code in <code>etuutt_bot/services/role.py</code> <pre><code>class MergeStrategy(Enum):\n    \"\"\"Strat\u00e9gie pour la fusion de plusieurs objets.\"\"\"\n\n    Intersection = 1\n    \"\"\"On garde l'intersection. ex: `[a, b, c] &amp; [b, c, d] =&gt; [b, c]`.\"\"\"\n    Union = 2\n    \"\"\"On garde l'union. ex: `[a, b, c] | [b, c, d] =&gt; [a, b, c, d]`.\"\"\"\n    Clear = 3\n    \"\"\"On ne garde rien. ex: `[a, b, c] | [b, c, d] =&gt; []`\"\"\"\n</code></pre>"},{"location":"reference/services/role/#etuutt_bot.services.role.MergeStrategy.Clear","title":"<code>Clear = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>On ne garde rien. ex: <code>[a, b, c] | [b, c, d] =&gt; []</code></p>"},{"location":"reference/services/role/#etuutt_bot.services.role.MergeStrategy.Intersection","title":"<code>Intersection = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>On garde l'intersection. ex: <code>[a, b, c] &amp; [b, c, d] =&gt; [b, c]</code>.</p>"},{"location":"reference/services/role/#etuutt_bot.services.role.MergeStrategy.Union","title":"<code>Union = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>On garde l'union. ex: <code>[a, b, c] | [b, c, d] =&gt; [a, b, c, d]</code>.</p>"},{"location":"reference/services/role/#etuutt_bot.services.role.RoleService","title":"<code>RoleService</code>","text":"<p>Service de gestion des r\u00f4les du serveur.</p> Source code in <code>etuutt_bot/services/role.py</code> <pre><code>class RoleService:\n    \"\"\"Service de gestion des r\u00f4les du serveur.\"\"\"\n\n    def __init__(self, bot: EtuUTTBot):\n        self._bot = bot\n\n    def get_duplicates(self, *, case_sensitive: bool = True) -&gt; list[list[Role]]:\n        \"\"\"Cherche et retourne tous les r\u00f4les qui sont dupliqu\u00e9s.\n\n        Returns:\n            La liste des listes de duplication.\n            Chaque \u00e9l\u00e9ment de la liste est une liste dont tous les\n            \u00e9l\u00e9ments sont des r\u00f4les dupliqu\u00e9s.\n        \"\"\"\n\n        def sort_key(r):\n            return r.name if case_sensitive else r.name.upper()\n\n        roles = sorted(self._bot.watched_guild.roles, key=sort_key)\n\n        res = []\n        for _, group in itertools.groupby(roles, key=sort_key):\n            values = list(group)\n            if len(values) &gt; 1:\n                res.append(values)\n        return res\n\n    def get_duplicate(self, role: Role, *, case_sensitive: bool = True) -&gt; list[Role]:\n        \"\"\"Cherche et retourne tous les r\u00f4les qui ont le m\u00eame nom que le r\u00f4le donn\u00e9.\n\n        Returns:\n            La liste des r\u00f4les dupliqu\u00e9s.\n            Le r\u00f4le pass\u00e9 en param\u00e8tre est inclus dedans.\n        \"\"\"\n        if case_sensitive:\n            return [r for r in self._bot.watched_guild.roles if r.name == role.name]\n        return [r for r in self._bot.watched_guild.roles if r.name.lower() == role.name.lower()]\n\n    @staticmethod\n    def combined_perms(roles: list[Role], *, merge_strategy: MergeStrategy) -&gt; Permissions:\n        \"\"\"Calcule et renvoie le jeu de permissions correspondant \u00e0 la strat\u00e9gie donn\u00e9e.\n\n        Args:\n            roles: les r\u00f4les dont on veut combiner les permissions\n            merge_strategy: la strat\u00e9gie de combinaison des permissions\n\n        Returns:\n            Le jeu de permission obtenu par la combinaison des permissions de tous les r\u00f4les\n        \"\"\"\n        perms = [role.permissions for role in roles]\n        if merge_strategy == MergeStrategy.Intersection:\n            return reduce(operator.or_, perms)\n        if merge_strategy == MergeStrategy.Union:\n            return reduce(operator.and_, perms)\n        if merge_strategy == MergeStrategy.Clear:\n            return Permissions.none()\n        assert_never(merge_strategy)\n\n    async def merge(self, roles: list[Role], *, merge_perms_strategy: MergeStrategy) -&gt; Role:\n        \"\"\"Fusionne les r\u00f4les donn\u00e9s, avec leurs permissions et leurs membres, en un seul.\n\n        Le r\u00f4le gard\u00e9 est celui de la liste avec le plus de membres.\n        Tous les membres de tous les r\u00f4les de la liste re\u00e7oivent le r\u00f4le gard\u00e9.\n        Tous les autres r\u00f4les sont supprim\u00e9s.\n\n        Warning:\n            Cette fonction peut n\u00e9cessiter beaucoup d'appels \u00e0 l'API Discord\n            (un pour chaque membre qui n'a pas d\u00e9j\u00e0 le r\u00f4le conserv\u00e9,\n            plus un pour chaque r\u00f4le supprim\u00e9,\n            plus un pour \u00e9diter les permissions du r\u00f4le gard\u00e9).\n            Utilisez-la avec parcimonie\n\n        Args:\n            roles: la liste des r\u00f4les \u00e0 fusionner\n            merge_perms_strategy: la strat\u00e9gie de fusion des permissions \u00e0 utiliser\n\n        Returns:\n            Le r\u00f4le r\u00e9sultant de la fusion.\n        \"\"\"\n        # keep the role which has the most members,\n        # in order to minimize the number of api calls when merging members\n        to_keep = max(roles, key=lambda r: len(r.members))\n        # set of members which must be assigned to the kept role\n        members = {\n            member for role in roles for member in role.members if to_keep not in member.roles\n        }\n        for member in members:\n            await member.add_roles(to_keep)\n        await to_keep.edit(\n            permissions=self.combined_perms(roles, merge_strategy=merge_perms_strategy)\n        )\n        to_delete = [r for r in roles if r != to_keep]\n        for role in to_delete:\n            await role.delete(reason=\"Fusion de r\u00f4les dupliqu\u00e9s\")\n        return to_keep\n</code></pre>"},{"location":"reference/services/role/#etuutt_bot.services.role.RoleService.combined_perms","title":"<code>combined_perms(roles, *, merge_strategy)</code>  <code>staticmethod</code>","text":"<p>Calcule et renvoie le jeu de permissions correspondant \u00e0 la strat\u00e9gie donn\u00e9e.</p> <p>Parameters:</p> Name Type Description Default <code>roles</code> <code>list[Role]</code> <p>les r\u00f4les dont on veut combiner les permissions</p> required <code>merge_strategy</code> <code>MergeStrategy</code> <p>la strat\u00e9gie de combinaison des permissions</p> required <p>Returns:</p> Type Description <code>Permissions</code> <p>Le jeu de permission obtenu par la combinaison des permissions de tous les r\u00f4les</p> Source code in <code>etuutt_bot/services/role.py</code> <pre><code>@staticmethod\ndef combined_perms(roles: list[Role], *, merge_strategy: MergeStrategy) -&gt; Permissions:\n    \"\"\"Calcule et renvoie le jeu de permissions correspondant \u00e0 la strat\u00e9gie donn\u00e9e.\n\n    Args:\n        roles: les r\u00f4les dont on veut combiner les permissions\n        merge_strategy: la strat\u00e9gie de combinaison des permissions\n\n    Returns:\n        Le jeu de permission obtenu par la combinaison des permissions de tous les r\u00f4les\n    \"\"\"\n    perms = [role.permissions for role in roles]\n    if merge_strategy == MergeStrategy.Intersection:\n        return reduce(operator.or_, perms)\n    if merge_strategy == MergeStrategy.Union:\n        return reduce(operator.and_, perms)\n    if merge_strategy == MergeStrategy.Clear:\n        return Permissions.none()\n    assert_never(merge_strategy)\n</code></pre>"},{"location":"reference/services/role/#etuutt_bot.services.role.RoleService.get_duplicate","title":"<code>get_duplicate(role, *, case_sensitive=True)</code>","text":"<p>Cherche et retourne tous les r\u00f4les qui ont le m\u00eame nom que le r\u00f4le donn\u00e9.</p> <p>Returns:</p> Type Description <code>list[Role]</code> <p>La liste des r\u00f4les dupliqu\u00e9s.</p> <code>list[Role]</code> <p>Le r\u00f4le pass\u00e9 en param\u00e8tre est inclus dedans.</p> Source code in <code>etuutt_bot/services/role.py</code> <pre><code>def get_duplicate(self, role: Role, *, case_sensitive: bool = True) -&gt; list[Role]:\n    \"\"\"Cherche et retourne tous les r\u00f4les qui ont le m\u00eame nom que le r\u00f4le donn\u00e9.\n\n    Returns:\n        La liste des r\u00f4les dupliqu\u00e9s.\n        Le r\u00f4le pass\u00e9 en param\u00e8tre est inclus dedans.\n    \"\"\"\n    if case_sensitive:\n        return [r for r in self._bot.watched_guild.roles if r.name == role.name]\n    return [r for r in self._bot.watched_guild.roles if r.name.lower() == role.name.lower()]\n</code></pre>"},{"location":"reference/services/role/#etuutt_bot.services.role.RoleService.get_duplicates","title":"<code>get_duplicates(*, case_sensitive=True)</code>","text":"<p>Cherche et retourne tous les r\u00f4les qui sont dupliqu\u00e9s.</p> <p>Returns:</p> Type Description <code>list[list[Role]]</code> <p>La liste des listes de duplication.</p> <code>list[list[Role]]</code> <p>Chaque \u00e9l\u00e9ment de la liste est une liste dont tous les</p> <code>list[list[Role]]</code> <p>\u00e9l\u00e9ments sont des r\u00f4les dupliqu\u00e9s.</p> Source code in <code>etuutt_bot/services/role.py</code> <pre><code>def get_duplicates(self, *, case_sensitive: bool = True) -&gt; list[list[Role]]:\n    \"\"\"Cherche et retourne tous les r\u00f4les qui sont dupliqu\u00e9s.\n\n    Returns:\n        La liste des listes de duplication.\n        Chaque \u00e9l\u00e9ment de la liste est une liste dont tous les\n        \u00e9l\u00e9ments sont des r\u00f4les dupliqu\u00e9s.\n    \"\"\"\n\n    def sort_key(r):\n        return r.name if case_sensitive else r.name.upper()\n\n    roles = sorted(self._bot.watched_guild.roles, key=sort_key)\n\n    res = []\n    for _, group in itertools.groupby(roles, key=sort_key):\n        values = list(group)\n        if len(values) &gt; 1:\n            res.append(values)\n    return res\n</code></pre>"},{"location":"reference/services/role/#etuutt_bot.services.role.RoleService.merge","title":"<code>merge(roles, *, merge_perms_strategy)</code>  <code>async</code>","text":"<p>Fusionne les r\u00f4les donn\u00e9s, avec leurs permissions et leurs membres, en un seul.</p> <p>Le r\u00f4le gard\u00e9 est celui de la liste avec le plus de membres. Tous les membres de tous les r\u00f4les de la liste re\u00e7oivent le r\u00f4le gard\u00e9. Tous les autres r\u00f4les sont supprim\u00e9s.</p> Warning <p>Cette fonction peut n\u00e9cessiter beaucoup d'appels \u00e0 l'API Discord (un pour chaque membre qui n'a pas d\u00e9j\u00e0 le r\u00f4le conserv\u00e9, plus un pour chaque r\u00f4le supprim\u00e9, plus un pour \u00e9diter les permissions du r\u00f4le gard\u00e9). Utilisez-la avec parcimonie</p> <p>Parameters:</p> Name Type Description Default <code>roles</code> <code>list[Role]</code> <p>la liste des r\u00f4les \u00e0 fusionner</p> required <code>merge_perms_strategy</code> <code>MergeStrategy</code> <p>la strat\u00e9gie de fusion des permissions \u00e0 utiliser</p> required <p>Returns:</p> Type Description <code>Role</code> <p>Le r\u00f4le r\u00e9sultant de la fusion.</p> Source code in <code>etuutt_bot/services/role.py</code> <pre><code>async def merge(self, roles: list[Role], *, merge_perms_strategy: MergeStrategy) -&gt; Role:\n    \"\"\"Fusionne les r\u00f4les donn\u00e9s, avec leurs permissions et leurs membres, en un seul.\n\n    Le r\u00f4le gard\u00e9 est celui de la liste avec le plus de membres.\n    Tous les membres de tous les r\u00f4les de la liste re\u00e7oivent le r\u00f4le gard\u00e9.\n    Tous les autres r\u00f4les sont supprim\u00e9s.\n\n    Warning:\n        Cette fonction peut n\u00e9cessiter beaucoup d'appels \u00e0 l'API Discord\n        (un pour chaque membre qui n'a pas d\u00e9j\u00e0 le r\u00f4le conserv\u00e9,\n        plus un pour chaque r\u00f4le supprim\u00e9,\n        plus un pour \u00e9diter les permissions du r\u00f4le gard\u00e9).\n        Utilisez-la avec parcimonie\n\n    Args:\n        roles: la liste des r\u00f4les \u00e0 fusionner\n        merge_perms_strategy: la strat\u00e9gie de fusion des permissions \u00e0 utiliser\n\n    Returns:\n        Le r\u00f4le r\u00e9sultant de la fusion.\n    \"\"\"\n    # keep the role which has the most members,\n    # in order to minimize the number of api calls when merging members\n    to_keep = max(roles, key=lambda r: len(r.members))\n    # set of members which must be assigned to the kept role\n    members = {\n        member for role in roles for member in role.members if to_keep not in member.roles\n    }\n    for member in members:\n        await member.add_roles(to_keep)\n    await to_keep.edit(\n        permissions=self.combined_perms(roles, merge_strategy=merge_perms_strategy)\n    )\n    to_delete = [r for r in roles if r != to_keep]\n    for role in to_delete:\n        await role.delete(reason=\"Fusion de r\u00f4les dupliqu\u00e9s\")\n    return to_keep\n</code></pre>"},{"location":"reference/services/ue/","title":"Ue","text":""},{"location":"reference/services/ue/#etuutt_bot.services.ue.UeService","title":"<code>UeService</code>","text":"<p>Service de gestion des UEs, avec leurs r\u00f4les, salons et cat\u00e9gories.</p> Warning <p>Faire correspondre les noms des UEs tels qu'ils peuvent apparaitre dans la configuration, les noms des r\u00f4les et les noms des salons, peut demander une certaine gymnastique entre majuscules et minuscules.</p> <p>C'est pourquoi il est important de garder en t\u00eate les conventions suivantes :</p> <ul> <li>les noms dans la configuration sont en majuscules (GE21, MATH01, PHYS11...)</li> <li>les noms des r\u00f4les sont en majuscules (GE21, MATH01, PHYS11...)</li> <li>les noms des salons sont en minuscules (ge21, math01, phys11...)</li> <li>les noms des cat\u00e9gories sont en majuscules (ME, CS, TM...)</li> </ul> Source code in <code>etuutt_bot/services/ue.py</code> <pre><code>class UeService:\n    \"\"\"Service de gestion des UEs, avec leurs r\u00f4les, salons et cat\u00e9gories.\n\n    Warning:\n        Faire correspondre les noms des UEs tels qu'ils peuvent apparaitre\n        dans la configuration, les noms des r\u00f4les et les noms des salons,\n        peut demander une certaine gymnastique entre majuscules et minuscules.\n\n        C'est pourquoi il est important de garder en t\u00eate les conventions suivantes :\n\n        - les noms dans la configuration sont en majuscules (GE21, MATH01, PHYS11...)\n        - les noms des r\u00f4les sont en majuscules (GE21, MATH01, PHYS11...)\n        - les noms des salons sont en minuscules (ge21, math01, phys11...)\n        - les noms des cat\u00e9gories sont en majuscules (ME, CS, TM...)\n    \"\"\"\n\n    def __init__(self, bot: EtuUTTBot):\n        self._bot = bot\n\n    @staticmethod\n    async def delete_channel(channel: TextChannel, *, delete_role: bool = False) -&gt; None:\n        \"\"\"Supprime un salon d'UE.\n\n        Args:\n            channel: Le salon \u00e0 supprimer\n            delete_role: si `True`, supprime \u00e9galement le r\u00f4le associ\u00e9 \u00e0 l'UE\n        \"\"\"\n        if delete_role:\n            ue_role = next(\n                (r for r in channel.guild.roles if r.name.lower() == channel.name),\n                None,\n            )\n            if ue_role is not None:\n                await ue_role.delete(reason=\"Suppression du r\u00f4le associ\u00e9 \u00e0 un salon d'UE\")\n        await channel.delete(reason=\"Suppression d'un salon d'UE\")\n\n    async def delete_all_channels(\n        self, category: CategoryChannel, *, delete_roles: bool = False\n    ) -&gt; int:\n        \"\"\"Supprime tous les salons d'UE de la cat\u00e9gorie.\n\n        Args:\n            category: la cat\u00e9gorie dans laquelle supprimer les salons d'UE.\n            delete_roles: si True, les r\u00f4les associ\u00e9s aux salons sont aussi supprim\u00e9s\n\n        Returns:\n            Le nombre de salons qui ont \u00e9t\u00e9 supprim\u00e9s\n        \"\"\"\n        ues_names = next(\n            (cat.ues for cat in self._bot.settings.categories if cat.id == category.id),\n            None,\n        )\n        if not ues_names:\n            return 0\n        channels = [c for c in category.text_channels if c.name.upper() in ues_names]\n        for channel in channels:\n            await self.delete_channel(channel, delete_role=delete_roles)\n        return len(channels)\n\n    async def create_channel(self, name: str) -&gt; (TextChannel, Role):\n        \"\"\"Cr\u00e9e un salon d'UE.\n\n        Si le r\u00f4le correspondant \u00e0 l'UE n'existe pas encore, le cr\u00e9e \u00e9galement.\n\n        Args:\n            name: le nom du salon \u00e0 cr\u00e9er.\n\n        Returns:\n            Le salon cr\u00e9\u00e9.\n\n        Raises:\n            AlreadyExistsError:\n                Un salon avec ce nom existe d\u00e9j\u00e0.\n            MissingConfigurationError:\n                Le nom donn\u00e9 ne correspond \u00e0 rien dans la configuration.\n        \"\"\"\n        guild = self._bot.watched_guild\n        settings = self._bot.settings\n        name = name.upper()\n        if any(c.name == name.lower() for c in guild.text_channels):\n            raise AlreadyExistsError\n\n        category_settings = next((c for c in settings.categories if name in c.ues), None)\n        if category_settings is None:\n            raise MissingConfigurationError\n        category = next((c for c in guild.categories if c.id == category_settings.id), None)\n        if category is None:\n            raise CategoryMissingError\n\n        role = next((r for r in guild.roles if r.name == name), None)\n        if role is None:\n            role = await guild.create_role(\n                name=name, reason=f\"Cr\u00e9ation d'un r\u00f4le pour l'UE {name}\"\n            )\n\n        moderator_role = guild.get_role(self._bot.settings.guild.special_roles.moderator)\n        elected = guild.get_role(category_settings.elected_role)\n        overwrites = {\n            guild.default_role: PermissionOverwrite(read_messages=False),\n            role: PermissionOverwrite(read_messages=True),\n            moderator_role: PermissionOverwrite(read_messages=True),\n        }\n        if elected:\n            overwrites[elected] = PermissionOverwrite(read_messages=True)\n\n        return await category.create_text_channel(\n            name.lower(), overwrites=overwrites, reason=f\"Cr\u00e9ation d'un salon pour l'UE {name}\"\n        ), role\n\n    def get_missing_channels(self, category: CategoryChannel = None) -&gt; set[LowerStr]:\n        \"\"\"Renvoie le nom de tous les salons d'UEs manquant sur le serveur.\"\"\"\n        if category:\n            ues = {\n                LowerStr(ue.lower())\n                for ue in next(\n                    (cat for cat in self._bot.settings.categories if cat.id == category.id), None\n                ).ues\n            }\n            existing = {\n                LowerStr(channel.name)  # les noms des salons Discord sont en minuscule par d\u00e9faut\n                for channel in category.text_channels\n            }\n            return ues - existing\n        ues = {LowerStr(ue.lower()) for cat in self._bot.settings.categories for ue in cat.ues}\n        existing = {\n            LowerStr(channel.name)  # les noms des salons Discord sont en minuscule par d\u00e9faut\n            for channel in self._bot.watched_guild.text_channels\n        }\n        return ues - existing\n</code></pre>"},{"location":"reference/services/ue/#etuutt_bot.services.ue.UeService.create_channel","title":"<code>create_channel(name)</code>  <code>async</code>","text":"<p>Cr\u00e9e un salon d'UE.</p> <p>Si le r\u00f4le correspondant \u00e0 l'UE n'existe pas encore, le cr\u00e9e \u00e9galement.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>le nom du salon \u00e0 cr\u00e9er.</p> required <p>Returns:</p> Type Description <code>(TextChannel, Role)</code> <p>Le salon cr\u00e9\u00e9.</p> <p>Raises:</p> Type Description <code>AlreadyExistsError</code> <p>Un salon avec ce nom existe d\u00e9j\u00e0.</p> <code>MissingConfigurationError</code> <p>Le nom donn\u00e9 ne correspond \u00e0 rien dans la configuration.</p> Source code in <code>etuutt_bot/services/ue.py</code> <pre><code>async def create_channel(self, name: str) -&gt; (TextChannel, Role):\n    \"\"\"Cr\u00e9e un salon d'UE.\n\n    Si le r\u00f4le correspondant \u00e0 l'UE n'existe pas encore, le cr\u00e9e \u00e9galement.\n\n    Args:\n        name: le nom du salon \u00e0 cr\u00e9er.\n\n    Returns:\n        Le salon cr\u00e9\u00e9.\n\n    Raises:\n        AlreadyExistsError:\n            Un salon avec ce nom existe d\u00e9j\u00e0.\n        MissingConfigurationError:\n            Le nom donn\u00e9 ne correspond \u00e0 rien dans la configuration.\n    \"\"\"\n    guild = self._bot.watched_guild\n    settings = self._bot.settings\n    name = name.upper()\n    if any(c.name == name.lower() for c in guild.text_channels):\n        raise AlreadyExistsError\n\n    category_settings = next((c for c in settings.categories if name in c.ues), None)\n    if category_settings is None:\n        raise MissingConfigurationError\n    category = next((c for c in guild.categories if c.id == category_settings.id), None)\n    if category is None:\n        raise CategoryMissingError\n\n    role = next((r for r in guild.roles if r.name == name), None)\n    if role is None:\n        role = await guild.create_role(\n            name=name, reason=f\"Cr\u00e9ation d'un r\u00f4le pour l'UE {name}\"\n        )\n\n    moderator_role = guild.get_role(self._bot.settings.guild.special_roles.moderator)\n    elected = guild.get_role(category_settings.elected_role)\n    overwrites = {\n        guild.default_role: PermissionOverwrite(read_messages=False),\n        role: PermissionOverwrite(read_messages=True),\n        moderator_role: PermissionOverwrite(read_messages=True),\n    }\n    if elected:\n        overwrites[elected] = PermissionOverwrite(read_messages=True)\n\n    return await category.create_text_channel(\n        name.lower(), overwrites=overwrites, reason=f\"Cr\u00e9ation d'un salon pour l'UE {name}\"\n    ), role\n</code></pre>"},{"location":"reference/services/ue/#etuutt_bot.services.ue.UeService.delete_all_channels","title":"<code>delete_all_channels(category, *, delete_roles=False)</code>  <code>async</code>","text":"<p>Supprime tous les salons d'UE de la cat\u00e9gorie.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>CategoryChannel</code> <p>la cat\u00e9gorie dans laquelle supprimer les salons d'UE.</p> required <code>delete_roles</code> <code>bool</code> <p>si True, les r\u00f4les associ\u00e9s aux salons sont aussi supprim\u00e9s</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>Le nombre de salons qui ont \u00e9t\u00e9 supprim\u00e9s</p> Source code in <code>etuutt_bot/services/ue.py</code> <pre><code>async def delete_all_channels(\n    self, category: CategoryChannel, *, delete_roles: bool = False\n) -&gt; int:\n    \"\"\"Supprime tous les salons d'UE de la cat\u00e9gorie.\n\n    Args:\n        category: la cat\u00e9gorie dans laquelle supprimer les salons d'UE.\n        delete_roles: si True, les r\u00f4les associ\u00e9s aux salons sont aussi supprim\u00e9s\n\n    Returns:\n        Le nombre de salons qui ont \u00e9t\u00e9 supprim\u00e9s\n    \"\"\"\n    ues_names = next(\n        (cat.ues for cat in self._bot.settings.categories if cat.id == category.id),\n        None,\n    )\n    if not ues_names:\n        return 0\n    channels = [c for c in category.text_channels if c.name.upper() in ues_names]\n    for channel in channels:\n        await self.delete_channel(channel, delete_role=delete_roles)\n    return len(channels)\n</code></pre>"},{"location":"reference/services/ue/#etuutt_bot.services.ue.UeService.delete_channel","title":"<code>delete_channel(channel, *, delete_role=False)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Supprime un salon d'UE.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>TextChannel</code> <p>Le salon \u00e0 supprimer</p> required <code>delete_role</code> <code>bool</code> <p>si <code>True</code>, supprime \u00e9galement le r\u00f4le associ\u00e9 \u00e0 l'UE</p> <code>False</code> Source code in <code>etuutt_bot/services/ue.py</code> <pre><code>@staticmethod\nasync def delete_channel(channel: TextChannel, *, delete_role: bool = False) -&gt; None:\n    \"\"\"Supprime un salon d'UE.\n\n    Args:\n        channel: Le salon \u00e0 supprimer\n        delete_role: si `True`, supprime \u00e9galement le r\u00f4le associ\u00e9 \u00e0 l'UE\n    \"\"\"\n    if delete_role:\n        ue_role = next(\n            (r for r in channel.guild.roles if r.name.lower() == channel.name),\n            None,\n        )\n        if ue_role is not None:\n            await ue_role.delete(reason=\"Suppression du r\u00f4le associ\u00e9 \u00e0 un salon d'UE\")\n    await channel.delete(reason=\"Suppression d'un salon d'UE\")\n</code></pre>"},{"location":"reference/services/ue/#etuutt_bot.services.ue.UeService.get_missing_channels","title":"<code>get_missing_channels(category=None)</code>","text":"<p>Renvoie le nom de tous les salons d'UEs manquant sur le serveur.</p> Source code in <code>etuutt_bot/services/ue.py</code> <pre><code>def get_missing_channels(self, category: CategoryChannel = None) -&gt; set[LowerStr]:\n    \"\"\"Renvoie le nom de tous les salons d'UEs manquant sur le serveur.\"\"\"\n    if category:\n        ues = {\n            LowerStr(ue.lower())\n            for ue in next(\n                (cat for cat in self._bot.settings.categories if cat.id == category.id), None\n            ).ues\n        }\n        existing = {\n            LowerStr(channel.name)  # les noms des salons Discord sont en minuscule par d\u00e9faut\n            for channel in category.text_channels\n        }\n        return ues - existing\n    ues = {LowerStr(ue.lower()) for cat in self._bot.settings.categories for ue in cat.ues}\n    existing = {\n        LowerStr(channel.name)  # les noms des salons Discord sont en minuscule par d\u00e9faut\n        for channel in self._bot.watched_guild.text_channels\n    }\n    return ues - existing\n</code></pre>"},{"location":"reference/services/user/","title":"User","text":""},{"location":"reference/services/user/#etuutt_bot.services.user.UserService","title":"<code>UserService</code>","text":"Source code in <code>etuutt_bot/services/user.py</code> <pre><code>class UserService:\n    NICKNAME_MAX_LEN = 32\n\n    def __init__(self, bot: EtuUTTBot):\n        self._bot = bot\n\n    def get_server_nickname(self, user: ApiUserSchema) -&gt; str:\n        \"\"\"Retourne le nom d'utilisateur qui va \u00eatre attribu\u00e9 \u00e0 l'utilisateur donn\u00e9.\n\n        Le nom d'utilisateur retourn\u00e9 est compos\u00e9 de 32 caract\u00e8res au maximum,\n        limitation impos\u00e9e par Discord.\n\n        Args:\n            user: Les donn\u00e9es utilisateur, telles que retourn\u00e9es par l'API du site \u00e9tu\n\n        Returns:\n            Le nom d'utilisateur compos\u00e9 du pr\u00e9nom, du nom et du statut de l'utilisateur,\n            soit sa branche, soit \"Ancien \u00e9tu\", soit \"Enseignant\".\n        \"\"\"\n        pseudo = f\"{user.first_name.title()} {user.last_name.upper()}\"\n        member_type = user.member_type\n        if member_type == MemberType.Student:\n            pseudo += \" - \" + \"/\".join(user.branch_levels)\n        elif member_type == MemberType.FormerStudent:\n            pseudo += \" - Ancien \u00e9tu\"\n        elif member_type == MemberType.Teacher:\n            pseudo += \" - Enseignant\"\n        else:\n            assert_never(member_type)\n        if len(pseudo) &gt; self.NICKNAME_MAX_LEN and \" \" in user.first_name:\n            # If he has several first names we only keep the first one\n            pseudo = f\"{user.first_name.split(' ')[0]} {pseudo.removeprefix(user.first_name)}\"\n        if len(pseudo) &gt; self.NICKNAME_MAX_LEN:\n            # if there is no other way to shorten the nickname, slice it (not ideal)\n            logging.warning(f\"Le nom de l'utilisateur {pseudo} est trop long. V\u00e9rifiez son pseudo\")\n            pseudo = pseudo[: self.NICKNAME_MAX_LEN]\n        return pseudo\n\n    def get_member_roles(self, user: ApiUserSchema) -&gt; set[Role]:\n        \"\"\"Retourne les r\u00f4les qui devraient \u00eatre attribu\u00e9s \u00e0 l'utilisateur donn\u00e9.\n\n        Args:\n            user: Les donn\u00e9es utilisateur, telles que retourn\u00e9es par l'API du site \u00e9tu\n\n        Returns:\n            L'ensemble des r\u00f4les par d\u00e9faut \u00e0 donner \u00e0 l'utilisateur donn\u00e9.\n            C'est-\u00e0-dire :\n            - Si c'est un \u00e9tudiant :\n                - le r\u00f4le `\u00e9tudiant`\n                - le(s) r\u00f4le(s) de la ou des branches de sa formation.\n                - les r\u00f4les correspondant \u00e0 ses UEs du semestre (s'il en a)\n            - Si c'est un ancien \u00e9tudiant : le r\u00f4le `ancien \u00e9tudiant`\n            - Si c'est un enseignant : le r\u00f4le `enseignant`\n        \"\"\"\n        member_type = user.member_type\n        special_ids = self._bot.settings.guild.special_roles\n        guild = self._bot.watched_guild\n        if member_type == MemberType.Student:\n            branches = {r for r in guild.roles if r.name.upper() in user.branches}\n            ues = {r for r in guild.roles if r.name.upper() in user.ues}\n            return {guild.get_role(special_ids.student)} | branches | ues\n        if member_type == MemberType.FormerStudent:\n            return {guild.get_role(special_ids.former_student)}\n        if member_type == MemberType.Teacher:\n            return {guild.get_role(special_ids.teacher)}\n        assert_never(member_type)\n\n    async def sync(self, member: discord.Member, user: ApiUserSchema):\n        \"\"\"Synchronise le membre du serveur avec les donn\u00e9es de l'api du site \u00e9tu.\n\n        Args:\n            member: Le membre du serveur Discord \u00e0 synchroniser\n            user: Les donn\u00e9es de l'API\n        \"\"\"\n        nickname = self.get_server_nickname(user)\n        roles = self.get_member_roles(user)\n        if nickname == member.nick and roles &lt;= set(member.roles):\n            # user already synced\n            return\n\n        upmost_role: Role = max(self._bot.watched_guild.get_member(self._bot.user.id).roles)\n        reason_msg = f\"Authentification \u00e9tu de : {member.global_name}\"\n        if any(r &gt;= upmost_role for r in member.roles):\n            # if the bot try to deal with a role higher\n            # than its own highest role, discord returns a 403.\n            # Thus, those must be given without using the `edit` method.\n            # Moreover, the bot cannot edit the nicknames of users with higher roles.\n            roles -= set(member.roles[1:])\n            await member.add_roles(*roles, reason=reason_msg)\n            return\n        roles |= set(member.roles)\n        await member.edit(nick=nickname, roles=roles, reason=reason_msg)\n</code></pre>"},{"location":"reference/services/user/#etuutt_bot.services.user.UserService.get_member_roles","title":"<code>get_member_roles(user)</code>","text":"<p>Retourne les r\u00f4les qui devraient \u00eatre attribu\u00e9s \u00e0 l'utilisateur donn\u00e9.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>ApiUserSchema</code> <p>Les donn\u00e9es utilisateur, telles que retourn\u00e9es par l'API du site \u00e9tu</p> required <p>Returns:</p> Type Description <code>set[Role]</code> <p>L'ensemble des r\u00f4les par d\u00e9faut \u00e0 donner \u00e0 l'utilisateur donn\u00e9.</p> <code>set[Role]</code> <p>C'est-\u00e0-dire :</p> <code>set[Role]</code> <ul> <li>Si c'est un \u00e9tudiant :</li> <li>le r\u00f4le <code>\u00e9tudiant</code></li> <li>le(s) r\u00f4le(s) de la ou des branches de sa formation.</li> <li>les r\u00f4les correspondant \u00e0 ses UEs du semestre (s'il en a)</li> </ul> <code>set[Role]</code> <ul> <li>Si c'est un ancien \u00e9tudiant : le r\u00f4le <code>ancien \u00e9tudiant</code></li> </ul> <code>set[Role]</code> <ul> <li>Si c'est un enseignant : le r\u00f4le <code>enseignant</code></li> </ul> Source code in <code>etuutt_bot/services/user.py</code> <pre><code>def get_member_roles(self, user: ApiUserSchema) -&gt; set[Role]:\n    \"\"\"Retourne les r\u00f4les qui devraient \u00eatre attribu\u00e9s \u00e0 l'utilisateur donn\u00e9.\n\n    Args:\n        user: Les donn\u00e9es utilisateur, telles que retourn\u00e9es par l'API du site \u00e9tu\n\n    Returns:\n        L'ensemble des r\u00f4les par d\u00e9faut \u00e0 donner \u00e0 l'utilisateur donn\u00e9.\n        C'est-\u00e0-dire :\n        - Si c'est un \u00e9tudiant :\n            - le r\u00f4le `\u00e9tudiant`\n            - le(s) r\u00f4le(s) de la ou des branches de sa formation.\n            - les r\u00f4les correspondant \u00e0 ses UEs du semestre (s'il en a)\n        - Si c'est un ancien \u00e9tudiant : le r\u00f4le `ancien \u00e9tudiant`\n        - Si c'est un enseignant : le r\u00f4le `enseignant`\n    \"\"\"\n    member_type = user.member_type\n    special_ids = self._bot.settings.guild.special_roles\n    guild = self._bot.watched_guild\n    if member_type == MemberType.Student:\n        branches = {r for r in guild.roles if r.name.upper() in user.branches}\n        ues = {r for r in guild.roles if r.name.upper() in user.ues}\n        return {guild.get_role(special_ids.student)} | branches | ues\n    if member_type == MemberType.FormerStudent:\n        return {guild.get_role(special_ids.former_student)}\n    if member_type == MemberType.Teacher:\n        return {guild.get_role(special_ids.teacher)}\n    assert_never(member_type)\n</code></pre>"},{"location":"reference/services/user/#etuutt_bot.services.user.UserService.get_server_nickname","title":"<code>get_server_nickname(user)</code>","text":"<p>Retourne le nom d'utilisateur qui va \u00eatre attribu\u00e9 \u00e0 l'utilisateur donn\u00e9.</p> <p>Le nom d'utilisateur retourn\u00e9 est compos\u00e9 de 32 caract\u00e8res au maximum, limitation impos\u00e9e par Discord.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>ApiUserSchema</code> <p>Les donn\u00e9es utilisateur, telles que retourn\u00e9es par l'API du site \u00e9tu</p> required <p>Returns:</p> Type Description <code>str</code> <p>Le nom d'utilisateur compos\u00e9 du pr\u00e9nom, du nom et du statut de l'utilisateur,</p> <code>str</code> <p>soit sa branche, soit \"Ancien \u00e9tu\", soit \"Enseignant\".</p> Source code in <code>etuutt_bot/services/user.py</code> <pre><code>def get_server_nickname(self, user: ApiUserSchema) -&gt; str:\n    \"\"\"Retourne le nom d'utilisateur qui va \u00eatre attribu\u00e9 \u00e0 l'utilisateur donn\u00e9.\n\n    Le nom d'utilisateur retourn\u00e9 est compos\u00e9 de 32 caract\u00e8res au maximum,\n    limitation impos\u00e9e par Discord.\n\n    Args:\n        user: Les donn\u00e9es utilisateur, telles que retourn\u00e9es par l'API du site \u00e9tu\n\n    Returns:\n        Le nom d'utilisateur compos\u00e9 du pr\u00e9nom, du nom et du statut de l'utilisateur,\n        soit sa branche, soit \"Ancien \u00e9tu\", soit \"Enseignant\".\n    \"\"\"\n    pseudo = f\"{user.first_name.title()} {user.last_name.upper()}\"\n    member_type = user.member_type\n    if member_type == MemberType.Student:\n        pseudo += \" - \" + \"/\".join(user.branch_levels)\n    elif member_type == MemberType.FormerStudent:\n        pseudo += \" - Ancien \u00e9tu\"\n    elif member_type == MemberType.Teacher:\n        pseudo += \" - Enseignant\"\n    else:\n        assert_never(member_type)\n    if len(pseudo) &gt; self.NICKNAME_MAX_LEN and \" \" in user.first_name:\n        # If he has several first names we only keep the first one\n        pseudo = f\"{user.first_name.split(' ')[0]} {pseudo.removeprefix(user.first_name)}\"\n    if len(pseudo) &gt; self.NICKNAME_MAX_LEN:\n        # if there is no other way to shorten the nickname, slice it (not ideal)\n        logging.warning(f\"Le nom de l'utilisateur {pseudo} est trop long. V\u00e9rifiez son pseudo\")\n        pseudo = pseudo[: self.NICKNAME_MAX_LEN]\n    return pseudo\n</code></pre>"},{"location":"reference/services/user/#etuutt_bot.services.user.UserService.sync","title":"<code>sync(member, user)</code>  <code>async</code>","text":"<p>Synchronise le membre du serveur avec les donn\u00e9es de l'api du site \u00e9tu.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>Member</code> <p>Le membre du serveur Discord \u00e0 synchroniser</p> required <code>user</code> <code>ApiUserSchema</code> <p>Les donn\u00e9es de l'API</p> required Source code in <code>etuutt_bot/services/user.py</code> <pre><code>async def sync(self, member: discord.Member, user: ApiUserSchema):\n    \"\"\"Synchronise le membre du serveur avec les donn\u00e9es de l'api du site \u00e9tu.\n\n    Args:\n        member: Le membre du serveur Discord \u00e0 synchroniser\n        user: Les donn\u00e9es de l'API\n    \"\"\"\n    nickname = self.get_server_nickname(user)\n    roles = self.get_member_roles(user)\n    if nickname == member.nick and roles &lt;= set(member.roles):\n        # user already synced\n        return\n\n    upmost_role: Role = max(self._bot.watched_guild.get_member(self._bot.user.id).roles)\n    reason_msg = f\"Authentification \u00e9tu de : {member.global_name}\"\n    if any(r &gt;= upmost_role for r in member.roles):\n        # if the bot try to deal with a role higher\n        # than its own highest role, discord returns a 403.\n        # Thus, those must be given without using the `edit` method.\n        # Moreover, the bot cannot edit the nicknames of users with higher roles.\n        roles -= set(member.roles[1:])\n        await member.add_roles(*roles, reason=reason_msg)\n        return\n    roles |= set(member.roles)\n    await member.edit(nick=nickname, roles=roles, reason=reason_msg)\n</code></pre>"},{"location":"reference/web/routes/","title":"Serveur web","text":""},{"location":"reference/web/routes/#etuutt_bot.routes.home.handler","title":"<code>handler(req)</code>  <code>async</code>","text":"Source code in <code>etuutt_bot/routes/home.py</code> <pre><code>async def handler(req: web.Request) -&gt; web.Response:\n    api_settings: ApiConfig = req.app[\"bot\"].settings.etu_api\n    raise web.HTTPFound(  # HTTP 302\n        f\"{api_settings.url}/oauth/authorize\"\n        f\"?client_id={api_settings.client_id}&amp;response_type=code&amp;state={req.app['api_state']}\"\n    )\n</code></pre>"},{"location":"reference/web/routes/#etuutt_bot.routes.login.handler","title":"<code>handler(req)</code>  <code>async</code>","text":"Source code in <code>etuutt_bot/routes/login.py</code> <pre><code>async def handler(req: web.Request) -&gt; web.Response:\n    # Unauthorized if not code in query string\n    api_settings: ApiConfig = req.app[\"bot\"].settings.etu_api\n    if not req.query.get(\"code\") or req.query.get(\"state\") != req.app[\"api_state\"]:\n        return web.HTTPUnauthorized()  # HTTP 401\n    # Request to obtain the access token\n    auth = aiohttp.BasicAuth(\n        str(api_settings.client_id), api_settings.client_secret.get_secret_value()\n    )\n    data = {\"grant_type\": \"authorization_code\", \"code\": req.query.get(\"code\")}\n    async with req.app[\"bot\"].session.post(\n        f\"{api_settings.url}/oauth/token\", auth=auth, data=data\n    ) as response:\n        if response.status != 200:\n            return web.Response(status=response.status)\n        resp = await response.json()\n        try:\n            token = resp[\"access_token\"]\n        except KeyError:\n            return web.HTTPBadRequest()  # HTTP 400\n    guild_settings: GuildConfig = req.app[\"bot\"].settings.guild\n    return await aiohttp_jinja2.render_template_async(\n        \"form.html.jinja\",\n        req,\n        {\n            \"token\": token,\n            \"discord_link\": guild_settings.invite_link,\n            \"admin\": guild_settings.special_roles.admin,\n        },\n    )\n</code></pre>"},{"location":"reference/web/routes/#etuutt_bot.routes.role.handler","title":"<code>handler(req)</code>  <code>async</code>","text":"Source code in <code>etuutt_bot/routes/role.py</code> <pre><code>async def handler(req: web.Request) -&gt; web.Response:\n    if req.method != \"POST\":\n        return web.HTTPMethodNotAllowed(req.method, [\"POST\"])  # HTTP 405\n    post = await req.post()\n    bot: EtuUTTBot = req.app[\"bot\"]\n\n    if not \"etu-token\" and \"discord-username\" in post:\n        return web.HTTPBadRequest()\n\n    if post.get(\"check-GDPR\") != \"on\":\n        return await aiohttp_jinja2.render_template_async(\n            \"error.html.jinja\",\n            req,\n            {\n                \"error\": \"Vous n'avez pas coch\u00e9 la case de consentement RGPD. \"\n                \"Vos donn\u00e9es n'ont pas \u00e9t\u00e9 trait\u00e9es.\"\n            },\n        )\n\n    params = {\"access_token\": post.get(\"etu-token\")}\n    async with bot.session.get(\n        f\"{bot.settings.etu_api.url}/public/user/account\", params=params\n    ) as response:\n        if response.status != 200:\n            return web.Response(status=response.status)\n        try:\n            resp = (await response.json()).get(\"data\")\n            api_user = ApiUserSchema.model_validate(resp)\n        except ValidationError:\n            return web.HTTPBadRequest()\n\n    if member := bot.watched_guild.get_member_named(post.get(\"discord-username\")):\n        user_service = UserService(bot)\n        await user_service.sync(member, api_user)\n        return web.Response(text=\"Roles assigned!\")\n        # TODO: make better response\n    return await aiohttp_jinja2.render_template_async(\n        \"error.html.jinja\",\n        req,\n        {\n            \"error\": \"Utilisateur non trouv\u00e9 dans le serveur. \"\n            \"Avez-vous bien rejoint le serveur Discord ?&lt;br&gt;\"\n            \"Avez-vous bien rentr\u00e9 votre nom d'utilisateur et pas votre nom d'affichage ?\"\n        },\n    )\n</code></pre>"},{"location":"tutorials/doc/","title":"Utiliser la documentation","text":""},{"location":"tutorials/doc/#compiler-la-documentation-localement","title":"Compiler la documentation localement","text":"<p>Si le projet est install\u00e9 suivant les \u00e9tapes d\u00e9crites dans la section Installation et que vous avez choisi d'installer les d\u00e9pendances de documentation, vous pouvez compiler la documentation localement en ex\u00e9cutant la commande suivante :</p> <pre><code>mkdocs build\n</code></pre> <p>La documentation sera g\u00e9n\u00e9r\u00e9e dans le dossier <code>site</code>. Vous pouvez l'explorer dans votre navigateur en ouvrant le fichier <code>index.html</code>.</p>"},{"location":"tutorials/doc/#editer-la-documentation","title":"\u00c9diter la documentation","text":"<p>La documentation est \u00e9crite en Markdown et est g\u00e9n\u00e9r\u00e9e \u00e0 l'aide de MkDocs. Lorsque vous voulez travailler sur la documentation, vous pouvez lancer le serveur de d\u00e9veloppement de MkDocs :</p> <pre><code>mkdocs serve\n</code></pre> <p>Les changements apport\u00e9s \u00e0 la documentation seront automatiquement d\u00e9tect\u00e9s et la page web sera recharg\u00e9e.</p> <p>Les fichiers de documentation sont situ\u00e9s dans le dossier <code>docs</code>.</p> <p>La documentation est \u00e9crite en Markdown, avec MkdDocs et l'extension Material. Si vous n'\u00eates pas familiers avec ces technologies, veuillez consulter les documentations officielles :</p> <ul> <li>Markdown</li> <li>MkDocs</li> <li>Material for MkDocs</li> </ul>"},{"location":"tutorials/doc/#ajouter-ou-retirer-un-fichier","title":"Ajouter ou retirer un fichier","text":"<p>Pour ajouter un fichier, cr\u00e9ez un fichier Markdown dans le dossier <code>docs</code>. Pour retirer un fichier, supprimez le fichier Markdown correspondant. Apr\u00e8s toute op\u00e9ration d'ajout ou de suppression, il est n\u00e9cessaire d'\u00e9diter la table des mati\u00e8res du fichier <code>mkdocs.yaml</code>.</p> <p>La partie \u00e0 modifier dans le fichier <code>mkdocs.yaml</code> est la section <code>nav</code>. Cette section contient une liste de liens vers les fichiers de documentation avec les titres \u00e0 afficher dans la table des mati\u00e8res.</p> <p>Par exemple, si vous voulez ajouter un fichier <code>foo.md</code> dans la section <code>Tutoriel</code>, Votre section <code>nav</code> devra ressembler \u00e0 ceci :</p> <pre><code>nav:\n    -   Accueil: index.md\n    -   Tutoriel:\n            -   Installation: tutoriel/install.md\n            -   foo: tutoriel/foo.md\n    - # ...\n</code></pre>"},{"location":"tutorials/doc/#norme-de-documentation","title":"Norme de documentation","text":"<p>La documentation est \u00e9crite selon la m\u00e9thode Diataxis. Si vous n'\u00eates pas familiers avec, consultez-la.</p>"},{"location":"tutorials/doc/#deployer-la-documentation","title":"D\u00e9ployer la documentation","text":"<p>Le d\u00e9ploiement de la documentation est automatique.</p> <p>Le site est d\u00e9ploy\u00e9 sur GitHub Pages \u00e0 chaque push sur la branche <code>main</code>.</p> <p>Le workflow de d\u00e9ploiement est d\u00e9fini dans le fichier <code>.github/workflows/docs.yaml</code>.</p>"},{"location":"tutorials/install/","title":"Installer le projet","text":""},{"location":"tutorials/install/#prerequis","title":"Pr\u00e9requis","text":"<p>Pour installer le projet, vous aurez besoin de :</p> <ul> <li>git (documentation officielle)</li> <li>Python &gt;=3.10 (documentation officielle)</li> </ul> <p>Si une ou plusieurs de ces d\u00e9pendances ne sont pas pr\u00e9sentes sur votre ordinateur, r\u00e9f\u00e9rez-vous aux instructions d'installation donn\u00e9es ci-dessous. Si toutes les d\u00e9pendances sont pr\u00e9sentes et \u00e0 jour, vous pouvez passer directement \u00e0 la partie suivante.</p>"},{"location":"tutorials/install/#python","title":"Python","text":"<p>Le projet est con\u00e7u pour fonctionner avec Python 3.10 ou au-dessus.</p> <p>Pour v\u00e9rifier votre version de Python, ex\u00e9cutez la commande suivante dans votre terminal :</p> <pre><code>python --version\n</code></pre> <p>Si la commande renvoie une version inf\u00e9rieure \u00e0 3.10 ou si la commande n'est pas reconnue, vous devez installer Python.</p> WindowsLinuxmacOS Avec l'ex\u00e9cutableAvec WingetAvec Scoop <p>Rendez-vous sur le site officiel de Python, t\u00e9l\u00e9chargez le programme d'installation et ex\u00e9cutez-le.</p> <p>Path</p> <p>Pensez \u00e0 cocher la case <code>Add Python to PATH</code> lors de l'installation.</p> <p>dans Powershell avec acc\u00e8s admins :</p> <pre><code>winget install Python.Python\n</code></pre> <p>dans Powershell :</p> <pre><code>scoop install python\n</code></pre> <p>Sur Linux, vous pouvez installer Python \u00e0 l'aide de votre gestionnaire de paquets.</p> Debian/UbuntuFedoraArch Linux <pre><code>sudo apt install python3\n# on sait jamais\nsudo apt install python-is-python3\n</code></pre> <p>Par d\u00e9faut, Ubuntu 22.04 utilise Python 3.10. Ce n'est pas la plus r\u00e9cente, mais elle est compatible avec le projet.</p> <p>Note</p> <p>Comme le gestionnaire APT est souvent en retard stable, il est conseill\u00e9 d'utiliser <code>pyenv</code> si vous voulez utiliser la version la plus \u00e0 jour de Python. Voir sa documentation.</p> <p>Alternativement, il est possible d'ajouter le PPA deadsnakes pour avoir un choix de versions de Python sur Ubuntu :</p> <pre><code>sudo add-apt-repository ppa:deadsnakes/ppa\n</code></pre> <pre><code>sudo dnf install python3\n</code></pre> <pre><code>sudo pacman -Syu python\n</code></pre> <p>Sur macOS, vous pouvez installer Python \u00e0 l'aide de Homebrew.</p> <pre><code>brew install python\n</code></pre>"},{"location":"tutorials/install/#git","title":"Git","text":"<p>Git est un logiciel de gestion de versions d\u00e9centralis\u00e9. Il est utilis\u00e9 pour g\u00e9rer le code source du projet.</p> <p>Si Git n'est pas d\u00e9j\u00e0 install\u00e9, suivez les instructions suivantes :</p> WindowsLinuxmacOS Avec l'ex\u00e9cutableAvec WingetAvec Scoop <p>Rendez-vous sur le  site officiel de Git, t\u00e9l\u00e9chargez le programme d'installation et ex\u00e9cutez-le.</p> <p>Dans Powershell avec acc\u00e8s admins :</p> <pre><code>winget install Git.Git\n</code></pre> <p>Dans Powershell :</p> <pre><code>scoop install git\n</code></pre> <p>Sur Linux, vous pouvez installer Git \u00e0 l'aide de votre gestionnaire de paquets.</p> Debian/UbuntuFedoraArch Linux <pre><code>sudo apt install git\n</code></pre> <pre><code>sudo dnf install git\n</code></pre> <pre><code>sudo pacman -Syu git\n</code></pre> <p>Sur macOS, vous pouvez installer Git \u00e0 l'aide de Homebrew.</p> <pre><code>brew install git\n</code></pre> <p>Pour v\u00e9rifier que l'installation a r\u00e9ussi, ex\u00e9cutez la commande suivante dans votre terminal :</p> <pre><code>git --version\n</code></pre>"},{"location":"tutorials/install/#mise-en-place-du-projet","title":"Mise en place du projet","text":"<p>Clonez le d\u00e9p\u00f4t Git du projet :</p> <pre><code>git clone https://github.com/ungdev/EtuUTT-Discord-Bot.git\n</code></pre> <p>Puis, placez-vous dans le r\u00e9pertoire :</p> <pre><code>cd EtuUTT-Discord-Bot\n</code></pre> <p>Assurez-vous que vous \u00eates bien sur la branche <code>main</code></p> <pre><code>git checkout main\n</code></pre> <p>Puis installez les d\u00e9pendances (de pr\u00e9f\u00e9rence dans un venv). Vous pouvez choisir d'installer les d\u00e9pendances pour compiler la documentation ou non.</p> <pre><code>pip install -U -r requirements-dev.txt\n# ou\npip install -U -r requirements-docs.txt\n</code></pre>"},{"location":"tutorials/install/#configuration-du-projet","title":"Configuration du projet","text":"<p>Pour bien fonctionner, le bot a besoin d'un peu de configuration. Deux fichiers contiennent des exemples de ce qui est attendu comme configuration. Copiez ces fichiers :</p> <pre><code>cp .env.example .env\ncp data/discord.example.toml data/discord.toml\n</code></pre>"},{"location":"tutorials/install/#ou-est-la-configuration","title":"O\u00f9 est la configuration ?","text":"<p>La configuration est r\u00e9partie entre les deux fichiers ainsi cr\u00e9\u00e9s, en suivant cet esprit :</p> <ul> <li>Le <code>.env</code> contient sp\u00e9cifiquement les variables d'environnement.   On y met les variables qui doivent \u00eatre les plus ais\u00e9ment accessibles   et modifiables par le SIA (Service d'Information des Associations).   Par exemple, les identifiants et mots de passe, le niveau de log et le token du bot.</li> <li>le <code>discord.toml</code> contient les variables relatives au bot et au serveur   qui n'ont pas un besoin imp\u00e9ratif d'\u00eatre modifi\u00e9es par le SIA.   Par exemple, l'id du serveur, les ids des r\u00f4les sp\u00e9ciaux   o\u00f9 les cat\u00e9gories destin\u00e9es \u00e0 avoir des salons d'UE.</li> </ul> <p>Pour savoir o\u00f9 une variable doit se trouver, imaginez-vous en tant qu'admin du serveur, puis imaginez-vous en tant que respo SIA. Ensuite, demandez-vous dans lequel de ces r\u00f4les, vous auriez le plus besoin d'acc\u00e9der \u00e0 cette variable.</p> <p>Si c'est en tant qu'admin Discord, la variable va dans le <code>discord.toml</code>. Si c'est en tant que respo SIA, la variable va dans le <code>.env</code>.</p>"},{"location":"tutorials/install/#creer-un-bot","title":"Cr\u00e9er un bot","text":"<p>Une grande partie de la configuration implique de conserver en dur des variables relatives directement \u00e0 Discord.</p> <p>Nous vous conseillons donc de cr\u00e9er un bot et un serveur rien qu'\u00e0 vous, qui vous serviront uniquement \u00e0 faire vos tests. La cr\u00e9ation du serveur est une t\u00e2che facile et laiss\u00e9e comme exercice au lecteur. Pour la cr\u00e9ation du bot, rendez-vous sur le portail des d\u00e9veloppeurs.</p> <p>\u00c7a devrait ressembler \u00e0 \u00e7a :</p> Portail des applications de Discord <p>Cliquez sur le bouton <code>New Application</code> en haut \u00e0 droite. Rentrez le nom de votre bot, acceptez les conditions de Discord et validez.</p> <p>Sur la page de votre application, rendez-vous dans l'onglet <code>Bot</code>. Si vous voulez, choisissez une ic\u00f4ne pour votre bot. G\u00e9n\u00e9rez un token et copiez-le dans la variable <code>BOT__TOKEN</code> du <code>.env</code></p> <p>Danger</p> <p>Le token de votre bot ne doit JAMAIS \u00eatre visible par quelqu'un d'autre. Si votre bot est r\u00e9cup\u00e9r\u00e9 une personne mal intentionn\u00e9e, \u00e7a peut \u00eatre extr\u00eamement dangereux. Faites bien attention \u00e0 \u00e7a.</p> <p>Rassurez-vous cependant, si jamais vous faites une erreur et que votre token se retrouve sur un repo GitHub ou dans un message Discord, Discord le d\u00e9tectera imm\u00e9diatement et r\u00e9voquera le token de votre bot sans attendre. Votre bot sera toujours utilisable, mais \u00e0 condition de g\u00e9n\u00e9rer un nouveau token.</p> <p>Une fois le token de votre bot renseign\u00e9, configurez les Intents. Le bot EtuUTT a besoin de tous les Intents.</p> Intents requis <p>Note</p> <p>Vous pouvez d\u00e9cocher la case <code>Public Bot</code> afin d'\u00e9viter que d'autres personnes que vous puissent ajouter votre bot de test dans des serveurs.</p> <p>Maintenant, rendez-vous dans l'onglet <code>Oauth2</code>, \u00e0 la section <code>URL Generator</code>. Renseignez le scope de votre application, puis les permissions requises. Le scope <code>bot</code> est n\u00e9cessaire. Pour les permissions, vous pouvez lui donner la permission <code>admin</code>, qui inclue toutes les autres.</p> Scope et permissions <p>Note</p> <p>Si jamais vous cr\u00e9ez un jour un bot destin\u00e9 \u00e0 \u00eatre r\u00e9ellement utilis\u00e9, \u00e9vitez de lui donner la permission administrateur. Pr\u00e9f\u00e9rez donner exactement les permissions n\u00e9cessaires et pas une de plus.</p> <p>Mais ici, on cr\u00e9e un bot de test, donc \u00e7a ne pose pas trop de probl\u00e8me et \u00e7a simplifie la configuration.</p> <p>Copiez-collez l'URL g\u00e9n\u00e9r\u00e9e dans un onglet de votre navigateur. Vous serez redirig\u00e9 vers la page d'invitation du bot sur un serveur. S\u00e9lectionnez votre serveur de test.</p> <p>Et voil\u00e0, votre bot est pr\u00eat \u00e0 fonctionner.</p>"},{"location":"tutorials/install/#configurer-le-serveur","title":"Configurer le serveur","text":"<p>Maintenant que vous avez votre bot et votre serveur, vous allez pouvoir remplir le <code>discord.toml</code>.</p> <p>Pour cela, vous devez faire les actions suivantes sur votre serveur :</p> <ol> <li>Copiez-collez l'id du serveur dans <code>guild.id</code></li> <li>Cr\u00e9ez un salon textuel et copiez-collez son id dans <code>guild.channel_admin_id</code></li> <li>G\u00e9n\u00e9rez une invitation et copiez-collez la dans <code>guild.invite_link</code></li> <li>Cr\u00e9ez cinq r\u00f4les, et copiez-collez leur id dans les cinq variables    de la cat\u00e9gorie <code>guild.special_roles</code></li> <li>Cr\u00e9ez deux cat\u00e9gories, nomm\u00e9es respectivement <code>ME</code> et <code>TC</code>    et copiez-collez leur id dans les variables <code>id</code> des deux <code>[[categories]]</code> correspondantes</li> <li>Cr\u00e9ez deux nouveaux r\u00f4les, et copiez-collez leur id dans les variables    <code>elected_role</code> des deux <code>[[categories]]</code></li> </ol> <p>Si vous voulez, vous pouvez rajouter plus de salons et de cat\u00e9gories, mais ce n'est pas n\u00e9cessaire pour le bon fonctionnement du bot.</p> <p>Je ne trouve pas les ids</p> <p>L'id d'un salon, d'une cat\u00e9gorie, d'un utilisateur et de presque tout sur Discord se trouve en faisant un clic droit sur l'objet et en cliquant sur \"Copier l'identifiant du [message/salon/utilisateur/...]\" dans le menu contextuel. Cette option devrait \u00eatre celle tout en bas.</p> <p>Si vous ne la voyez pas, vous devez vous rendre dans vos param\u00e8tres utilisateur, puis <code>Param\u00e8tres de l'appli</code> &gt; <code>Avanc\u00e9s</code> et activer le mode d\u00e9veloppeur.</p>"},{"location":"tutorials/install/#lancement-du-bot","title":"Lancement du bot","text":"<p>Maintenant que tout est configur\u00e9, vous pouvez lancer le bot. Pour cela, ex\u00e9cutez la commande suivante dans votre terminal :</p> <pre><code>python -m etuutt_bot\n</code></pre> <p>Rendez-vous dans le salon que vous avez configur\u00e9 comme \u00e9tant celui d\u00e9di\u00e9 \u00e0 l'administration du serveur. Le bot devrait y avoir post\u00e9 un message pour signaler sa mise en ligne.</p> <p>Si \u00e7a ne marche pas, vous pouvez trouver les logs dans le fichier <code>data/logs/log</code>.</p>"}]}